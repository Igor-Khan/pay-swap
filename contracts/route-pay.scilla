scilla_version 0

import PairUtils

library PaySwapLib

type Error =
  | CodeNotContractOwner

type Denom =
  | Zil
  | Token of ByStr20 (* token addr *)

type SwapDirection =
  | ZilToToken (* make swap ZIL to token type *)
  | TokenToZil (* make swap token to ZIL type *)

type ExactSide =
  | ExactInput
  | ExactOutput

(* pool, amount, limit amount, fee *)
type Swap =
  | Swap of
    (* x, y = zil_reserve, token_reserve *)
    (Pair Uint256 Uint256)
    (* Direction of the swap zil to token or token to zil *)
    SwapDirection
    Uint128 (* amount *)
    Uint128 (* limit *)


(* fee denominated in basis points (1 b.p. = 0.01%) *)
let fee_denom = Uint256 10000
let zero256 = Uint256 0
let zero128 = Uint128 0

let one_msg = 
  fun (msg : Message) => 
    let nil_msg = Nil {Message} in
      Cons {Message} msg nil_msg

let make_error =
  fun (result : Error) =>
    match result with
    | CodeNotContractOwner =>
      {
        _exception: "Sender is not contract owner";
        code: Int32 -1
      }
    end

let option_value =
  tfun 'A =>
  fun (default: 'A) =>
  fun (opt_val: Option 'A) =>
    match opt_val with
    | Some v => v
    | None => default
    end

let first_pair = @fst Uint128 Uint128
let second_pair = @snd Uint128 Uint128

let option_uint128 = @option_value Uint128

let grow_u128: Uint128 -> Uint256 =
  fun (v : Uint128) =>
    let some_big = builtin to_uint256 v in
    match some_big with
    | Some big => big
    | None => zero256 (* should never happen *)
    end

(* computes the amount of the fraction x / d that is in y *)
let fraction: Uint256 -> Uint256 -> Uint256 -> Uint256 =
  fun (d: Uint256) =>
  fun (x: Uint256) =>
  fun (y: Uint256) =>
    let d_times_y = builtin mul d y in
      builtin div d_times_y x

(* computes the output that should be taken from the output reserve
   when the given input amount is added to the input reserve *)
let output_for: Uint256 -> Uint256 -> Uint256 -> Uint256 =
  fun (input_amount: Uint256) =>
  fun (input_reserve: Uint256) =>
  fun (output_reserve: Uint256) =>
    let numerator = builtin mul input_amount output_reserve in
    let denominator = builtin add input_reserve input_amount in
      builtin div numerator denominator

(* computes the input that should be given to the input reserve
   when the given output amount is removed from the output reserve *)
let input_for: Uint256 -> Uint256 -> Uint256 -> Uint256 =
   fun (output_amount: Uint256) =>
   fun (input_reserve: Uint256) =>
   fun (output_reserve: Uint256) =>
     let numerator = builtin mul input_reserve output_amount in
     let denominator = builtin sub output_reserve output_amount in
      builtin div numerator denominator

let calc =
  fun (exact: ExactSide) =>
    match exact with
    | ExactInput => output_for
    | ExactOutput => input_for
    end

(* computes the corresponding input or output amount for
  the given exact output or input amount, pool, and direction *)
let amount_for: SwapDirection -> ExactSide -> Uint256 -> Uint256 -> Uint256 -> Uint256 =
  fun (direction: SwapDirection) =>
  fun (exact_side: ExactSide) =>
  fun (exact_amount: Uint256) =>
  fun (zil_reserve: Uint256) =>
  fun (token_reserve: Uint256) =>
    match direction with
    | ZilToToken => calc exact_side exact_amount zil_reserve token_reserve
    | TokenToZil => calc exact_side exact_amount token_reserve zil_reserve
    end

(* checks whether the result amount is within the user provided
  limit amount, which is dependent on whether the output or input
  result was the one being computed *)
let within_limits: Uint128 -> Uint128 -> ExactSide -> Bool =
  fun (result_amount: Uint128) =>
  fun (limit_amount: Uint128) =>
  fun (exact_side: ExactSide) =>
    match exact_side with
    | ExactInput =>
      (* we are given an exact input and are computing the output,
        which should be greater or equal to the limit *)
      uint128_ge result_amount limit_amount
    | ExactOutput =>
      (* we are given an exact output and are computing the input,
        which should be lower or equal to the limit *)
      uint128_ge limit_amount result_amount
    end

(* computes the result amount for the given swap *)
let result_for =
  fun (exact_amount: Uint256) =>
  fun (limit_amount: Uint256) =>
  fun (zil_reserve: Uint256) =>
  fun (token_reserve: Uint256) =>
  fun (direction: SwapDirection) =>
  fun (exact_side: ExactSide) =>
    amount_for direction exact_side exact_amount zil_reserve token_reserve


contract PaySwapContract
()


(* POOL token -> Pari{zil_reserve, token_reserve} *)
field pools: Map ByStr20 (Pair Uint128 Uint128) = Emp ByStr20 (Pair Uint128 Uint128)

(* token -> full zil_reserve amount *)
field total_contributions: Map ByStr20 Uint128 = Emp ByStr20 Uint128

(* token -> _sender -> started_zil_reserve *)
field balances: Map ByStr20 (Map ByStr20 Uint128) = Emp ByStr20 (Map ByStr20 Uint128)

(* fee for each swap *)
field swap_fee: Uint256 = Uint256 9970


procedure ThrowError(err : Error)
  e = make_error err;
  throw e
end

transition Test(zil_reserve: Uint256, zrc_reserve: Uint256, amount: Uint256, total_contribution: Uint256)
  fres = fraction amount zil_reserve total_contribution;
  output = output_for amount zil_reserve zrc_reserve;
  e = {
    _eventname: "Test";
    fres: fres;
    output: output
  };
  event e
end
