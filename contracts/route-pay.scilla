scilla_version 0

import PairUtils IntUtils BoolUtils

library PaySwapLib

type Error =
  | CodeNotContractOwner
  | CodePoolMissing
  | CodeNotWithin
  | CodeCannotBeZero
  | CodeRatesCannotBeFulfilled

type Denom =
  | Zil
  | Token

type SwapDirection =
  | ZilToToken (* make swap ZIL to token type *)
  | TokenToZil (* make swap token to ZIL type *)

type ExactSide =
  | ExactInput
  | ExactOutput

(* pool, amount, limit amount, fee *)
type Swap =
  | Swap of
    (* x, y = zil_reserve, token_reserve *)
    (Pair Uint256 Uint256)
    (* Direction of the swap zil to token or token to zil *)
    SwapDirection
    Uint128 (* amount *)
    Uint128 (* limit *)


let zero_address = 0x0000000000000000000000000000000000000000
(* fee denominated in basis points (1 b.p. = 0.01%) *)
let fee_denom = Uint256 10000
let zero256 = Uint256 0
let zero128 = Uint128 0
let one128 = Uint128 1

let zil = Zil
let zrc = Token

let one_msg = 
  fun (msg : Message) => 
    let nil_msg = Nil {Message} in
      Cons {Message} msg nil_msg

let make_error =
  fun (result : Error) =>
    match result with
    | CodeNotContractOwner =>
      {
        _exception: "Sender is not contract owner";
        code: Int32 -1
      }
    | CodePoolMissing =>
      {
        _exception: "Pool is missing";
        code: Int32 -2
      }
    | CodeNotWithin =>
      {
        _exception: "Amount is not within";
        code: Int32 -3
      }
    | CodeCannotBeZero =>
      {
        _exception: "Value cannot be zero";
        code: Int32 -4
      }
    | CodeRatesCannotBeFulfilled =>
      {
        _exception: "Requested rates cannot be fulfilled";
        code: Int32 -5
      }
    end

let option_value =
  tfun 'A =>
  fun (default: 'A) =>
  fun (opt_val: Option 'A) =>
    match opt_val with
    | Some v => v
    | None => default
    end

let first_pair = @fst Uint128 Uint128
let second_pair = @snd Uint128 Uint128

let option_uint128 = @option_value Uint128

let grow_u128: Uint128 -> Uint256 =
  fun (v : Uint128) =>
    let some_big = builtin to_uint256 v in
    match some_big with
    | Some big => big
    | None => zero256 (* should never happen *)
    end

let fall_u256: Uint256 -> Uint128 =
  fun (v : Uint256) =>
    let some_u128 = builtin to_uint128 v in
    match some_u128 with
    | Some u => u
    | None => zero128 (* should never happen *)
    end

(* computes the amount of the fraction x / d that is in y *)
let fraction: Uint256 -> Uint256 -> Uint256 -> Uint256 =
  fun (d: Uint256) =>
  fun (x: Uint256) =>
  fun (y: Uint256) =>
    let d_times_y = builtin mul d y in
      builtin div d_times_y x

(* computes the output that should be taken from the output reserve
   when the given input amount is added to the input reserve *)
let output_for: Uint256 -> Uint256 -> Uint256 -> Uint256 =
  fun (input_amount: Uint256) =>
  fun (input_reserve: Uint256) =>
  fun (output_reserve: Uint256) =>
    let numerator = builtin mul input_amount output_reserve in
    let denominator = builtin add input_reserve input_amount in
      builtin div numerator denominator

(* computes the input that should be given to the input reserve
   when the given output amount is removed from the output reserve *)
let input_for: Uint256 -> Uint256 -> Uint256 -> Uint256 =
   fun (output_amount: Uint256) =>
   fun (input_reserve: Uint256) =>
   fun (output_reserve: Uint256) =>
     let numerator = builtin mul input_reserve output_amount in
     let denominator = builtin sub output_reserve output_amount in
      builtin div numerator denominator

let calc =
  fun (exact: ExactSide) =>
    match exact with
    | ExactInput => output_for
    | ExactOutput => input_for
    end

(* computes the corresponding input or output amount for
  the given exact output or input amount, pool, and direction *)
let amount_for: SwapDirection -> ExactSide -> Uint256 -> Uint256 -> Uint256 -> Uint256 =
  fun (direction: SwapDirection) =>
  fun (exact_side: ExactSide) =>
  fun (exact_amount: Uint256) =>
  fun (zil_reserve: Uint256) =>
  fun (token_reserve: Uint256) =>
    match direction with
    | ZilToToken => calc exact_side exact_amount zil_reserve token_reserve
    | TokenToZil => calc exact_side exact_amount token_reserve zil_reserve
    end

(* checks whether the result amount is within the user provided
  limit amount, which is dependent on whether the output or input
  result was the one being computed *)
let within_limits: Uint128 -> Uint128 -> ExactSide -> Bool =
  fun (result_amount: Uint128) =>
  fun (limit_amount: Uint128) =>
  fun (exact_side: ExactSide) =>
    match exact_side with
    | ExactInput =>
      (* we are given an exact input and are computing the output,
        which should be greater or equal to the limit *)
      uint128_ge result_amount limit_amount
    | ExactOutput =>
      (* we are given an exact output and are computing the input,
        which should be lower or equal to the limit *)
      uint128_ge limit_amount result_amount
    end

let check_within_limits =
  fun (amount: Uint128) =>
  fun (max_token_amount: Uint128) =>
  fun (new_contribution: Uint128) =>
  fun (min_contribution_amount: Uint128) =>
    let token_lte_max = uint128_le amount max_token_amount in
    let contribution_gte_max = uint128_ge new_contribution min_contribution_amount in
      andb token_lte_max contribution_gte_max

let pool_from_denom =
  fun (denom: Denom) =>
  fun (input_amount: Uint128) =>
  fun (output_amount: Uint128) =>
  fun (x: Uint128) =>
  fun (y: Uint128) =>
    match denom with
    | Zil =>
      let new_x = builtin add x input_amount in
      let new_y = builtin sub y output_amount in
        Pair {Uint128 Uint128} new_x new_y
    | Token =>
      let new_x = builtin add x output_amount in
      let new_y = builtin sub y input_amount in
        Pair {Uint128 Uint128} new_x new_y
    end

let is_empty_pool =
  fun (x: Uint128) =>
  fun (y: Uint128) =>
    let x_empty = builtin lt x one128 in
    let y_empty = builtin lt y one128 in
      orb x_empty y_empty

contract PaySwapContract
()


(* POOL token -> Pari{zil_reserve, token_reserve} *)
field pools: Map ByStr20 (Pair Uint128 Uint128) = Emp ByStr20 (Pair Uint128 Uint128)

(* token -> full zil_reserve amount *)
field total_contributions: Map ByStr20 Uint128 = Emp ByStr20 Uint128

(* token -> _sender -> started_zil_reserve *)
field balances: Map ByStr20 (Map ByStr20 Uint128) = Emp ByStr20 (Map ByStr20 Uint128)

(* fee for each swap *)
field swap_fee: Uint256 = Uint256 9970


procedure ThrowError(err : Error)
  e = make_error err;
  throw e
end

(* EVENTS *)
procedure emitMintPool(token_address: ByStr20, address: ByStr20, amount: Uint128)
  e = {
    _eventname: "Mint";
    pool: token_address;
    address: address;
    amount: amount
  };
  event e
end

(* EVENTS *)

(* Checkers *)
procedure ThrowIfZero(v: Uint128)
  is_zero = builtin eq v zero128;
  match is_zero with
  | False =>
  | True =>
    err = CodeCannotBeZero;
    ThrowError err
  end
end
(* Checkers *)

procedure MakeSwap(
  token_address: ByStr20,
  input_amount: Uint128,
  output_amount: Uint128,
  denom: Denom,
  zil_reserve: Uint128,
  token_reserve: Uint128
)
  new_pool = pool_from_denom
    denom
    input_amount
    output_amount
    zil_reserve
    token_reserve;
  pools[token_address] := new_pool;

  (* emit swap event *)
  e = {
    _eventname: "Swapped";
    pool: token_address;
    address: _sender;
    input: input_amount;
    output: output_amount
  };
  event e
end

procedure SwapZIL(
  token_address: ByStr20,
  direction: SwapDirection,
  exact_side: ExactSide,
  pool: Pair Uint128 Uint128,
  exact_amount: Uint128,
  limit_amount: Uint128,
  deadline_block: BNum,
  recipient_address: ByStr20
)
  match pool with
  | Pair zil_reserve token_reserve =>
    zil_reserve_u256 = grow_u128 zil_reserve;
    token_reserve_u256 = grow_u128 token_reserve;
    exact_amount_u256 = grow_u128 exact_amount;

    calculated_amount_u256 = amount_for direction exact_side exact_amount_u256 zil_reserve_u256 token_reserve_u256;
    calculated_amount_u128 = fall_u256 calculated_amount_u256;

    is_within_limits = within_limits calculated_amount_u128 limit_amount exact_side;
    match is_within_limits with
    | False =>
      err = CodeRatesCannotBeFulfilled;
      ThrowError err
    | True =>
      match exact_side with
      | ExactInput =>
        match direction with
        | ZilToToken =>
          MakeSwap token_address exact_amount calculated_amount_u128 zil zil_reserve token_reserve
        | TokenToZil =>
          MakeSwap token_address exact_amount calculated_amount_u128 zrc zil_reserve token_reserve
        end
      | ExactOutput =>
        match direction with
        | ZilToToken =>
          MakeSwap token_address calculated_amount_u128 exact_amount zil zil_reserve token_reserve
        | TokenToZil =>
          MakeSwap token_address calculated_amount_u128 exact_amount zrc zil_reserve token_reserve
        end
      end
    end
  end
end


transition AddLiquidity(
  token_address : ByStr20,
  min_contribution_amount : Uint128,
  max_token_amount : Uint128,
  deadline_block : BNum
)
  (* ADD checks *)
  some_pool <- pools[token_address];

  match some_pool with
  | None =>
    (* INIT Pool *)
    new_pool = Pair {Uint128 Uint128} _amount max_token_amount;

    pools[token_address] := new_pool;
    balances[token_address][_sender] := _amount;
    total_contributions[token_address] := _amount;

    pool_event = {
      _eventname: "PoolCreated";
      pool: token_address
    };
    event pool_event;
    emitMintPool token_address _sender _amount
  | Some pool =>
    match pool with
    | Pair zil_reserve token_reserve =>
      some_total_contribution <- total_contributions[token_address];

      total_contribution = option_uint128 zero128 some_total_contribution;

      total_contribution_u256 = grow_u128 total_contribution;
      amount_u256 = grow_u128 _amount;
      zil_reserve_u256 = grow_u128 zil_reserve;
      token_reserve_u256 = grow_u128 token_reserve;

      (* dY = dX * Y / X *)
      (* dX is always the QA transferred *)
      result_u256 = fraction amount_u256 zil_reserve_u256 token_reserve_u256;
      result_u128 = fall_u256 result_u256;

      (* (_amount *  total_contribution) / x *)
      new_contribution_u256 = fraction amount_u256 zil_reserve_u256 total_contribution_u256;
      new_contribution_u128 = fall_u256 new_contribution_u256;

      is_within_limits = check_within_limits
        result_u128
        max_token_amount
        new_contribution_u128
        min_contribution_amount;
      
      match is_within_limits with
      | True =>
      | False =>
        err = CodeNotWithin;
        ThrowError err
      end;

      (* Receive tokens_in; *)

      new_pool =
        let new_x = builtin add zil_reserve _amount in
        let new_y = builtin add token_reserve result_u128 in
          Pair {Uint128 Uint128} new_x new_y;
      pools[token_address] := new_pool;

      existing_balance <- balances[token_address][_sender];

      match existing_balance with
      | Some balance =>
        new_balance = builtin add balance new_contribution_u128;
        balances[token_address][_sender] := new_balance
      | None =>
        balances[token_address][_sender] := new_contribution_u128
      end;

      new_total_contribution = builtin add total_contribution new_contribution_u128;
      total_contributions[token_address] := new_total_contribution;

      emitMintPool token_address _sender new_contribution_u128
    end
  end
end

transition RemoveLiquidity(
  token_address: ByStr20,
  contribution_amount: Uint128,
  min_zil_amount: Uint128,
  min_token_amount: Uint128,
  deadline_block: BNum
)
  some_pool <- pools[token_address];

  match some_pool with
  | Some pool =>
    match pool with
    | Pair zil_reserve token_reserve =>
      some_total_contribution <- total_contributions[token_address];

      total_contribution_u128 = option_uint128 zero128 some_total_contribution;

      ThrowIfZero total_contribution_u128;

      zil_reserve_u256 = grow_u128 zil_reserve;
      token_reserve_u256 = grow_u128 token_reserve;

      contribution_amount_u256 = grow_u128 contribution_amount;
      total_contribution_u256 = grow_u128 total_contribution_u128;

      zil_amount_u256 = fraction contribution_amount_u256 total_contribution_u256 zil_reserve_u256;
      token_amount_u256 = fraction contribution_amount_u256 total_contribution_u256 token_reserve_u256;

      zil_amount_u128 = fall_u256 zil_amount_u256;
      token_amount_u128 = fall_u256 token_amount_u256;

      is_within_limits =
        let zil_ok = uint128_ge zil_amount_u128 min_zil_amount in
        let token_ok = uint128_ge token_amount_u128 min_token_amount in
          andb zil_ok token_ok;

      match is_within_limits with
      | True =>
      | False =>
        err = CodeNotWithin;
        ThrowError err
      end;

      some_existing_balance <- balances[token_address][_sender];
      
      existing_balance = option_uint128 zero128 some_existing_balance;

      new_balance = builtin sub existing_balance contribution_amount;
      new_total_contribution = builtin sub total_contribution_u128 contribution_amount;

      new_x = builtin sub zil_reserve zil_amount_u128;
      new_y = builtin sub token_reserve token_amount_u128;
      is_empty_pool = is_empty_pool new_x new_y;

      match is_empty_pool with
      | True =>
        (* clear pool entries when there is no more liquidity *)
        delete pools[token_address];
        delete balances[token_address];
        delete total_contributions[token_address]
      | False =>
        new_pool = Pair {Uint128 Uint128} new_x new_y;

        pools[token_address] := new_pool;
        balances[token_address][_sender] := new_balance;
        total_contributions[token_address] := new_total_contribution
      end;

      (* zils_out = Coins zil zil_amount;
      tokens_out = Coins token token_amount;
      Send zils_out _sender;
      Send tokens_out _sender; *)

      e = {
        _eventname: "Burnt";
        pool: token_address;
        address: _sender;
        amount: contribution_amount
      };
      event e
    end
  | None =>
    err = CodePoolMissing;
    ThrowError err
  end
end

transition SwapExactZILForTokens(
  token_address : ByStr20,
  (* _amount: the zil amount to be sent in *)
  min_token_amount : Uint128,
  deadline_block : BNum,
  recipient_address : ByStr20
)
  some_pool <- pools[token_address];

  match some_pool with
  | Some pool =>
    direction = ZilToToken;
    exact_side = ExactInput;
    exact_amount = _amount;
    limit_amount = min_token_amount;

    SwapZIL
      token_address
      direction
      exact_side
      pool
      exact_amount
      limit_amount
      deadline_block
      recipient_address
  | None =>
    err = CodePoolMissing;
    ThrowError err
  end
end
