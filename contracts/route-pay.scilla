scilla_version 0

import IntUtils BoolUtils ListUtils

library PaySwapLib

type Error =
  | CodeNotContractOwner
  | CodePoolMissing
  | CodeNotWithin
  | CodeCannotBeZero
  | CodeRatesCannotBeFulfilled
  | CodeNotOperator
  | CodeTransactionExpired
  | CodeEmptyAddress
  | CodeMinLP
  | CodeMinBlocks

type Denom =
  | Zil
  | Token

type SwapDirection =
  | ZilToToken (* make swap ZIL to token type *)
  | TokenToZil (* make swap token to ZIL type *)

type ExactSide =
  | ExactInput
  | ExactOutput


let zero_address = 0x0000000000000000000000000000000000000000
let zero32 = Uint32 0
let zerobn = BNum 0
let one32 = Uint32 1
let zero256 = Uint256 0
let hundred256 = Uint256 100
let zero128 = Uint128 0
let two128 = Uint128 2
let one128 = Uint128 1
let fee_demon = Uint256 10000
let fee = Uint256 9970

let tt = True
let ff = False

let zil = Zil
let zrc = Token


let one_msg = 
  fun (msg : Message) => 
    let nil_msg = Nil {Message} in
      Cons {Message} msg nil_msg

let make_error =
  fun (result : Error) =>
    match result with
    | CodeNotContractOwner =>
      {
        _exception: "Sender is not contract owner";
        code: Int32 -1
      }
    | CodePoolMissing =>
      {
        _exception: "Pool is missing";
        code: Int32 -2
      }
    | CodeNotWithin =>
      {
        _exception: "Amount is not within";
        code: Int32 -3
      }
    | CodeCannotBeZero =>
      {
        _exception: "Value cannot be zero";
        code: Int32 -4
      }
    | CodeRatesCannotBeFulfilled =>
      {
        _exception: "Requested rates cannot be fulfilled";
        code: Int32 -5
      }
    | CodeNotOperator =>
      {
        _exception: "Sender is not operator";
        code: Int32 -6
      }
    | CodeTransactionExpired =>
      {
        _exception: "Deadline blocknumber is expired";
        code: Int32 -7
      }
    | CodeEmptyAddress =>
      {
        _exception: "Incorrect address";
        code: Int32 -8
      }
    | CodeMinLP =>
      {
        _exception: "LP less then min";
        code: Int32 -9
      }
    | CodeMinBlocks =>
      {
        _exception: "Rewards countdown";
        code: Int32 -10
      }
    end

let option_value =
  tfun 'A =>
  fun (default: 'A) =>
  fun (opt_val: Option 'A) =>
    match opt_val with
    | Some v => v
    | None => default
    end

let option_uint128 = @option_value Uint128
let option_bn = @option_value BNum
let addr_exists = @list_exists ByStr20
let list_length_addr = @list_length ByStr20


let grow_u128: Uint128 -> Uint256 =
  fun (v : Uint128) =>
    let some_big = builtin to_uint256 v in
    match some_big with
    | Some big => big
    | None => zero256 (* should never happen *)
    end

let fall_u256: Uint256 -> Uint128 =
  fun (v : Uint256) =>
    let some_u128 = builtin to_uint128 v in
    match some_u128 with
    | Some u => u
    | None => zero128 (* should never happen *)
    end

(* computes the amount of the fraction x / d that is in y *)
let fraction: Uint256 -> Uint256 -> Uint256 -> Uint256 =
  fun (d: Uint256) =>
  fun (x: Uint256) =>
  fun (y: Uint256) =>
    let d_times_y = builtin mul d y in
      builtin div d_times_y x

(* computes the output that should be taken from the output reserve
   when the given input amount is added to the input reserve *)
let output_for: Uint256 -> Uint256 -> Uint256 -> Uint256 =
  fun (input_amount: Uint256) =>
  fun (input_reserve: Uint256) =>
  fun (output_reserve: Uint256) =>
    let numerator = builtin mul input_amount output_reserve in
    let denominator = builtin add input_reserve input_amount in
      builtin div numerator denominator

(* computes the input that should be given to the input reserve
   when the given output amount is removed from the output reserve *)
let input_for: Uint256 -> Uint256 -> Uint256 -> Uint256 =
   fun (output_amount: Uint256) =>
   fun (input_reserve: Uint256) =>
   fun (output_reserve: Uint256) =>
     let numerator = builtin mul input_reserve output_amount in
     let denominator = builtin sub output_reserve output_amount in
      builtin div numerator denominator

let calc =
  fun (exact: ExactSide) =>
    match exact with
    | ExactInput => output_for
    | ExactOutput => input_for
    end

(* computes the corresponding input or output amount for
  the given exact output or input amount, pool, and direction *)
let amount_for: SwapDirection -> ExactSide -> Uint256 -> Uint256 -> Uint256 -> Uint256 =
  fun (direction: SwapDirection) =>
  fun (exact_side: ExactSide) =>
  fun (exact_amount: Uint256) =>
  fun (zil_reserve: Uint256) =>
  fun (token_reserve: Uint256) =>
    match direction with
    | ZilToToken => calc exact_side exact_amount zil_reserve token_reserve
    | TokenToZil => calc exact_side exact_amount token_reserve zil_reserve
    end

(* checks whether the result amount is within the user provided
  limit amount, which is dependent on whether the output or input
  result was the one being computed *)
let within_limits: Uint128 -> Uint128 -> ExactSide -> Bool =
  fun (result_amount: Uint128) =>
  fun (limit_amount: Uint128) =>
  fun (exact_side: ExactSide) =>
    match exact_side with
    | ExactInput =>
      (* we are given an exact input and are computing the output,
        which should be greater or equal to the limit *)
      uint128_ge result_amount limit_amount
    | ExactOutput =>
      (* we are given an exact output and are computing the input,
        which should be lower or equal to the limit *)
      uint128_ge limit_amount result_amount
    end

let check_within_limits =
  fun (amount: Uint128) =>
  fun (max_token_amount: Uint128) =>
  fun (new_contribution: Uint128) =>
  fun (min_contribution_amount: Uint128) =>
    let token_lte_max = uint128_le amount max_token_amount in
    let contribution_gte_max = uint128_ge new_contribution min_contribution_amount in
      andb token_lte_max contribution_gte_max

let pool_from_denom =
  fun (denom: Denom) =>
  fun (input_amount: Uint128) =>
  fun (output_amount: Uint128) =>
  fun (x: Uint128) =>
  fun (y: Uint128) =>
    match denom with
    | Zil =>
      let new_x = builtin add x input_amount in
      let new_y = builtin sub y output_amount in
        Pair {Uint128 Uint128} new_x new_y
    | Token =>
      let new_x = builtin sub x output_amount in
      let new_y = builtin add y input_amount in
        Pair {Uint128 Uint128} new_x new_y
    end

let is_empty_pool =
  fun (x: Uint128) =>
  fun (y: Uint128) =>
    let x_empty = builtin lt x one128 in
    let y_empty = builtin lt y one128 in
      orb x_empty y_empty

let get_fee =
  fun (value: Uint256) =>
  fun (fee: Uint256) =>
    let v_f = builtin mul value fee in
      builtin div v_f fee_demon

let check_operators =
  fun (operators: List ByStr20) =>
  fun (sender: ByStr20) =>
    let f =
      fun (a: ByStr20) =>
        builtin eq a sender in
    addr_exists f operators

let clac_percent =
  fun (t: Uint256) =>
  fun (b: Uint256) =>
  fun (percent: Uint256) =>
    let t_b = builtin mul b percent in
      builtin div t_b t


contract PaySwapContract
(
  init_owner: ByStr20,
  operators: List ByStr20
)

(* Contract owner *)
field owner: ByStr20 = init_owner

(* operators approvals for onwer transfer *)
field transfer_owner_approvals: Map ByStr20 (Map ByStr20 Bool) = Emp ByStr20 (Map ByStr20 Bool)

(* Numbers of approvals for transfer owner. *)
field number_approvals: Uint32 = zero32

(* POOL token -> Pari{zil_reserve, token_reserve} *)
field pools: Map ByStr20 (Pair Uint128 Uint128) = Emp ByStr20 (Pair Uint128 Uint128)

(* token -> full zil_reserve amount *)
field total_contributions: Map ByStr20 Uint128 = Emp ByStr20 Uint128

(* token -> _sender -> started_zil_reserve *)
field balances: Map ByStr20 (Map ByStr20 Uint128) = Emp ByStr20 (Map ByStr20 Uint128)

(* team rewards in ZILs *)
field contract_balance: Uint128 = zero128

(* fee for each swap - zil_fee, token_fee *)
field swap_fee: Pair Uint256 Uint256 = Pair {Uint256 Uint256} fee fee

(* A callback for interact with another contract. *)
field callback_addr: ByStr20 = zero_address

(* Rewards for LP provider. token / tokens_amount *)
field rewards: Map ByStr20 Uint128 = Emp ByStr20 Uint128

(* Pool for increase price with every swap. *)
field rewards_pool: ByStr20 = zero_address

(* Rewards timer, LP proverid can claim pear some blocks. *)
field rewards_blocks: Map ByStr20 BNum = Emp ByStr20 BNum

(* min blocks for rewards claim *)
field min_rewards_blocks: Int256 = Int256 1

(* Min number zil for LP providers. *)
field min_lp: Uint128 = Uint128 99000000000000


procedure ThrowError(err : Error)
  e = make_error err;
  throw e
end

(* EVENTS *)
procedure emitMintPool(token_address: ByStr20, address: ByStr20, amount: Uint128)
  e = {
    _eventname: "Mint";
    pool: token_address;
    address: address;
    amount: amount
  };
  event e
end
(* EVENTS *)

(* Checkers *)
procedure ThrowZero(v: Uint128)
  is_zero = builtin eq v zero128;
  match is_zero with
  | False =>
  | True =>
    err = CodeCannotBeZero;
    ThrowError err
  end
end

procedure OwnerOnly()
  contract_owner <- owner;
  is_owner = builtin eq _sender contract_owner;
  match is_owner with
  | True =>
  | False =>
    err = CodeNotContractOwner;
    ThrowError err
  end
end

procedure OperatorOnly()
  is_operator = check_operators operators _sender;
  match is_operator with
  | True =>
  | False =>
    err = CodeNotOperator;
    ThrowError err
  end
end

procedure CheckMinLP(lp: Uint128)
  min <- min_lp;
  is_min_lp = uint128_ge min lp;
  
  match is_min_lp with
  | True =>
    err = CodeMinLP;
    ThrowError err
  | False =>
  end
end

procedure ThrowExpired(deadline_block: BNum, current_block: BNum)
  is_not_expired = builtin blt current_block deadline_block;
  match is_not_expired with
  | True =>
  | False =>
    err = CodeTransactionExpired;
    ThrowError err
  end
end

procedure ThrowZeroAddress(address: ByStr20)
  is_zil = builtin eq address zero_address;
  match is_zil with
  | False =>
  | True =>
    err = CodeEmptyAddress;
    ThrowError err
  end
end

procedure CheckLimits(
  amount: Uint128,
  limit: Uint128,
  exact_side: ExactSide
)
  is_within_limits = within_limits amount limit exact_side;

  match is_within_limits with
  | False =>
    err = CodeRatesCannotBeFulfilled;
    ThrowError err
  | True =>
  end
end

procedure CheckBlockTimer(current_block: BNum)
  min_blocks <- min_rewards_blocks;
  some_rewards_blocks <- rewards_blocks[_sender];

  r_blocks = option_bn zerobn some_rewards_blocks;

  diff = builtin bsub current_block r_blocks;
  check = builtin lt min_blocks diff;

  match check with
  | True =>
  | False =>
    err = CodeMinBlocks;
    ThrowError err
  end
end
(* Checkers *)

(* MSG CALL *)
procedure AddFunds(recipient: ByStr20, amount: Uint128)
  msg = {
    _tag: "AddFunds";
    _recipient: recipient;
    _amount: amount
  };
  msgs = one_msg msg;
  send msgs
end

procedure CallTransferFrom(amount: Uint128, from: ByStr20, to: ByStr20, recipient: ByStr20)
  call_transfer_zlp = {
    _tag: "TransferFrom";
    _recipient: recipient;
    _amount: zero128;
    from: from;
    to: to;
    amount: amount
  };
  msgs = one_msg call_transfer_zlp;
  send msgs
end

procedure CallTransfer(to: ByStr20, amount: Uint128, recipient: ByStr20)
  msg_transfer = {
    _tag: "Transfer";
    _recipient: recipient;
    _amount: zero128;
    to: to;
    amount: amount
  };
  msgs = one_msg msg_transfer;
  send msgs
end
(* MSG CALL *)

procedure ReceiveRewards(
  token_address: ByStr20,
  zil_rewards: Uint128,
  tokens_rewards: Uint128
)
  is_zil_zero = builtin eq zil_rewards zero128;
  is_tokens_zero = builtin eq tokens_rewards zero128;

  match is_zil_zero with
  | True =>
  | False =>
    addr_rewards_pool <- rewards_pool;
    contract_rewards <- contract_balance;
    some_pool <- pools[addr_rewards_pool];

    match some_pool with
    | None => 
      new_contract_rewards = builtin add contract_rewards zil_rewards;
      contract_balance := new_contract_rewards
    | Some pool =>
      half = builtin div zil_rewards two128;
      new_contract_rewards = builtin add contract_rewards half;
      contract_balance := new_contract_rewards;

      match pool with
      | Pair zil tokens =>
        new_zil = builtin add zil half;
        new_pool = Pair {Uint128 Uint128} new_zil tokens;
        pools[addr_rewards_pool] := new_pool
      end
    end
  end;

  match is_tokens_zero with
  | True =>
  | False =>
    some_lp_rewards <- rewards[token_address];
    lp_rewards = option_uint128 zero128 some_lp_rewards;
    new_lp_rewards = builtin add lp_rewards tokens_rewards;
    rewards[token_address] := new_lp_rewards
  end
end

procedure AddLPCallBack(zil: Uint128, tokens: Uint128)
  recipient <- callback_addr;
  is_empty = builtin eq recipient zero_address;

  match is_empty with
  | False =>
    call_callback = {
      _tag: "AddLPCallBack";
      _recipient: recipient;
      _amount: zero128;
      initiator: _sender;
      zil: zil;
      tokens: tokens
    };
    msg = one_msg call_callback;
    send msg
  | True =>
  end
end

procedure RemoveLPCallBack(zil: Uint128, tokens: Uint128)
  recipient <- callback_addr;
  is_empty = builtin eq recipient zero_address;

  match is_empty with
  | False =>
    call_callback = {
      _tag: "RemoveLPCallBack";
      _recipient: recipient;
      _amount: zero128;
      initiator: _sender;
      zil: zil;
      tokens: tokens
    };
    msg = one_msg call_callback;
    send msg
  | True =>
  end
end

procedure CallBack(
  input_token: ByStr20,
  output_output: ByStr20,
  input_amount: Uint128,
  output_amount: Uint128,
  callback: Bool
)
  match callback with
  | True =>
    recipient <- callback_addr;

    is_empty = builtin eq recipient zero_address;

    match is_empty with
    | False =>
      call_callback = {
        _tag: "SwapCallBack";
        _recipient: recipient;
        _amount: zero128;
        initiator: _sender;
        input_amount: input_amount;
        output_amount: output_amount;
        input_token: input_token;
        output_output: output_output
      };
      msg = one_msg call_callback;
      send msg
    | True =>
    end
  | False =>
  end
end

procedure MakeSwap(
  token_address: ByStr20,
  input_amount: Uint128,
  output_amount: Uint128,
  denom: Denom,
  zil_reserve: Uint128,
  token_reserve: Uint128
)
  new_pool = pool_from_denom
    denom
    input_amount
    output_amount
    zil_reserve
    token_reserve;
  pools[token_address] := new_pool;

  e = {
    _eventname: "Swapped";
    token: token_address;
    address: _sender;
    input: input_amount;
    output: output_amount
  };
  event e
end

procedure SwapOptions(
  token_address: ByStr20,
  direction: SwapDirection,
  exact_side: ExactSide,
  exact_amount: Uint128,
  calculated_amount: Uint128,
  zil_reserve: Uint128,
  token_reserve: Uint128,
  callback: Bool
)
  match exact_side with
  | ExactInput =>
    match direction with
    | ZilToToken =>
      MakeSwap
        token_address
        exact_amount
        calculated_amount
        zil
        zil_reserve
        token_reserve;
      CallBack
        zero_address
        token_address
        exact_amount
        calculated_amount
        callback
    | TokenToZil =>
      MakeSwap
        token_address
        exact_amount
        calculated_amount
        zrc
        zil_reserve
        token_reserve;
      CallBack
        token_address
        zero_address
        exact_amount
        calculated_amount
        callback
    end
  | ExactOutput =>
    match direction with
    | ZilToToken =>
      MakeSwap
        token_address
        calculated_amount
        exact_amount
        zil
        zil_reserve
        token_reserve
    | TokenToZil =>
      MakeSwap
        token_address
        calculated_amount
        exact_amount
        zrc
        zil_reserve
        token_reserve
    end
  end
end

procedure SwapZIL(
  token_address: ByStr20,
  direction: SwapDirection,
  exact_side: ExactSide,
  pool: Pair Uint128 Uint128,
  exact_amount: Uint128,
  limit_amount: Uint128,
  recipient_address: ByStr20
)
  fee_pari <- swap_fee;

  match pool with
  | Pair zil_reserve token_reserve =>
    zil_reserve_u256 = grow_u128 zil_reserve;
    token_reserve_u256 = grow_u128 token_reserve;
    exact_amount_u256 = grow_u128 exact_amount;

    calculated_amount_u256 = amount_for
      direction
      exact_side
      exact_amount_u256
      zil_reserve_u256
      token_reserve_u256;
    
    match fee_pari with
    | Pair zil_fee tokens_fee =>
      match direction with
      | ZilToToken =>
        amount_token_u256 = get_fee calculated_amount_u256 tokens_fee;
        amount_zil_u256 = get_fee exact_amount_u256 zil_fee;

        tokens_fee_u256 = builtin sub calculated_amount_u256 amount_token_u256;
        zil_fee_u256 = builtin sub exact_amount_u256 amount_zil_u256;

        amount_token_u128 = fall_u256 amount_token_u256;
        tokens_fee_u128 = fall_u256 tokens_fee_u256;
        zil_fee_u128 = fall_u256 zil_fee_u256;

        CheckLimits amount_token_u128 limit_amount exact_side;

        SwapOptions
          token_address
          direction
          exact_side
          exact_amount
          amount_token_u128
          zil_reserve
          token_reserve
          tt;
        ReceiveRewards token_address zil_fee_u128 tokens_fee_u128;
        CallTransfer recipient_address amount_token_u128 token_address
      | TokenToZil =>
        amount_zil_u256 = get_fee calculated_amount_u256 zil_fee;
        amount_token_u256 = get_fee exact_amount_u256 tokens_fee;

        tokens_fee_u256 = builtin sub exact_amount_u256 amount_token_u256;
        zil_fee_u256 = builtin sub calculated_amount_u256 amount_zil_u256;

        amount_zil_u128 = fall_u256 amount_zil_u256;
        tokens_fee_u128 = fall_u256 tokens_fee_u256;
        zil_fee_u128 = fall_u256 zil_fee_u256;

        CheckLimits amount_zil_u128 limit_amount exact_side;

        SwapOptions
          token_address
          direction
          exact_side
          exact_amount
          amount_zil_u128
          zil_reserve
          token_reserve
          tt;
        ReceiveRewards token_address zil_fee_u128 tokens_fee_u128;
        AddFunds recipient_address amount_zil_u128
      end
    end
  end
end

(* user interactions *)
transition AddLiquidity(
  token_address : ByStr20,
  min_contribution_amount : Uint128,
  max_token_amount : Uint128,
  deadline_block : BNum
)
  current_block <- & BLOCKNUMBER;

  ThrowExpired deadline_block current_block;
  CheckMinLP _amount;
  ThrowZeroAddress token_address;
  ThrowZero max_token_amount;

  some_pool <- pools[token_address];

  match some_pool with
  | None =>
    CallTransferFrom max_token_amount _sender _this_address token_address;
    accept;
    (* INIT Pool *)
    new_pool = Pair {Uint128 Uint128} _amount max_token_amount;

    pools[token_address] := new_pool;
    balances[token_address][_sender] := _amount;
    total_contributions[token_address] := _amount;

    AddLPCallBack _amount max_token_amount;

    pool_event = {
      _eventname: "PoolCreated";
      pool: token_address
    };
    event pool_event;
    emitMintPool token_address _sender _amount
  | Some pool =>
    match pool with
    | Pair zil_reserve token_reserve =>
      some_total_contribution <- total_contributions[token_address];

      total_contribution = option_uint128 zero128 some_total_contribution;

      total_contribution_u256 = grow_u128 total_contribution;
      amount_u256 = grow_u128 _amount;
      zil_reserve_u256 = grow_u128 zil_reserve;
      token_reserve_u256 = grow_u128 token_reserve;

      (* dY = dX * Y / X *)
      (* dX is always the QA transferred *)
      result_u256 = fraction amount_u256 zil_reserve_u256 token_reserve_u256;
      result_u128 = fall_u256 result_u256;

      (* (_amount *  total_contribution) / x *)
      new_contribution_u256 = fraction amount_u256 zil_reserve_u256 total_contribution_u256;
      new_contribution_u128 = fall_u256 new_contribution_u256;

      is_within_limits = check_within_limits
        result_u128
        max_token_amount
        new_contribution_u128
        min_contribution_amount;

      match is_within_limits with
      | True =>
      | False =>
        err = CodeNotWithin;
        ThrowError err
      end;

      CallTransferFrom result_u128 _sender _this_address token_address;
      accept;

      new_x = builtin add zil_reserve _amount;
      new_y = builtin add token_reserve result_u128;
      new_pool = Pair {Uint128 Uint128} new_x new_y;
      pools[token_address] := new_pool;

      AddLPCallBack new_x new_y;

      existing_balance <- balances[token_address][_sender];

      match existing_balance with
      | Some balance =>
        new_balance = builtin add balance new_contribution_u128;
        balances[token_address][_sender] := new_balance
      | None =>
        balances[token_address][_sender] := new_contribution_u128
      end;

      new_total_contribution = builtin add total_contribution new_contribution_u128;
      total_contributions[token_address] := new_total_contribution;

      emitMintPool token_address _sender new_contribution_u128
    end
  end;
  rewards_blocks[_sender] := current_block
end

transition RemoveLiquidity(
  token_address: ByStr20,
  contribution_amount: Uint128,
  min_zil_amount: Uint128,
  min_token_amount: Uint128,
  deadline_block: BNum
)
  current_block <- & BLOCKNUMBER;

  ThrowExpired deadline_block current_block;
  ThrowZero contribution_amount;
  ThrowZero min_zil_amount;
  ThrowZero min_token_amount;

  some_pool <- pools[token_address];

  match some_pool with
  | Some pool =>
    match pool with
    | Pair zil_reserve token_reserve =>
      some_total_contribution <- total_contributions[token_address];

      total_contribution_u128 = option_uint128 zero128 some_total_contribution;

      ThrowZero total_contribution_u128;

      zil_reserve_u256 = grow_u128 zil_reserve;
      token_reserve_u256 = grow_u128 token_reserve;

      contribution_amount_u256 = grow_u128 contribution_amount;
      total_contribution_u256 = grow_u128 total_contribution_u128;

      zil_amount_u256 = fraction contribution_amount_u256 total_contribution_u256 zil_reserve_u256;
      token_amount_u256 = fraction contribution_amount_u256 total_contribution_u256 token_reserve_u256;

      zil_amount_u128 = fall_u256 zil_amount_u256;
      token_amount_u128 = fall_u256 token_amount_u256;

      is_within_limits =
        let zil_ok = uint128_ge zil_amount_u128 min_zil_amount in
        let token_ok = uint128_ge token_amount_u128 min_token_amount in
          andb zil_ok token_ok;

      match is_within_limits with
      | True =>
      | False =>
        err = CodeNotWithin;
        ThrowError err
      end;

      some_existing_balance <- balances[token_address][_sender];
      
      existing_balance = option_uint128 zero128 some_existing_balance;

      new_balance = builtin sub existing_balance contribution_amount;
      new_total_contribution = builtin sub total_contribution_u128 contribution_amount;

      new_x = builtin sub zil_reserve zil_amount_u128;
      new_y = builtin sub token_reserve token_amount_u128;
      is_empty_pool = is_empty_pool new_x new_y;

      match is_empty_pool with
      | True =>
        (* clear pool entries when there is no more liquidity *)
        delete pools[token_address];
        delete balances[token_address];
        delete total_contributions[token_address]
      | False =>
        new_pool = Pair {Uint128 Uint128} new_x new_y;

        pools[token_address] := new_pool;
        balances[token_address][_sender] := new_balance;
        total_contributions[token_address] := new_total_contribution
      end;

      CallTransfer _sender token_amount_u128 token_address;
      AddFunds _sender zil_amount_u128;
      RemoveLPCallBack zil_amount_u128 token_amount_u128;

      e = {
        _eventname: "Burnt";
        pool: token_address;
        address: _sender;
        amount: contribution_amount
      };
      event e
    end
  | None =>
    err = CodePoolMissing;
    ThrowError err
  end
end

transition SwapExactZILForTokens(
  token_address : ByStr20,
  min_token_amount : Uint128,
  deadline_block : BNum,
  recipient_address : ByStr20
)
  current_block <- & BLOCKNUMBER;

  ThrowExpired deadline_block current_block;
  ThrowZero _amount;
  ThrowZero min_token_amount;
  ThrowZeroAddress recipient_address;

  some_pool <- pools[token_address];

  match some_pool with
  | Some pool =>
    direction = ZilToToken;
    exact_side = ExactInput;

    accept;

    SwapZIL
      token_address
      direction
      exact_side
      pool
      _amount
      min_token_amount
      recipient_address
  | None =>
    err = CodePoolMissing;
    ThrowError err
  end
end

transition SwapExactTokensForZIL(
  token_address: ByStr20,
  token_amount: Uint128,
  min_zil_amount: Uint128,
  deadline_block: BNum,
  recipient_address: ByStr20
)
  current_block <- & BLOCKNUMBER;

  ThrowExpired deadline_block current_block;
  ThrowZero token_amount;
  ThrowZero min_zil_amount;
  ThrowZeroAddress recipient_address;

  some_pool <- pools[token_address];

  match some_pool with
  | Some pool =>
    direction = TokenToZil;
    exact_side = ExactInput;

    SwapZIL
      token_address
      direction
      exact_side
      pool
      token_amount
      min_zil_amount
      recipient_address
  | None =>
    err = CodePoolMissing;
    ThrowError err
  end
end

transition SwapExactTokensForTokens(
  token0_address: ByStr20,
  token1_address: ByStr20,
  token0_amount: Uint128,
  min_token1_amount: Uint128,
  deadline_block: BNum,
  recipient_address: ByStr20
)
  current_block <- & BLOCKNUMBER;

  ThrowExpired deadline_block current_block;
  ThrowZero token0_amount;
  ThrowZero min_token1_amount;
  ThrowZeroAddress recipient_address;

  some_pool0 <- pools[token0_address];
  some_pool1 <- pools[token1_address];

  match some_pool0 with
  | Some pool0 =>
    match some_pool1 with
    | Some pool1 =>
      exact_amount0_u256 = grow_u128 token0_amount;

      match pool0 with
      | Pair zil_reserve0 token_reserve0 =>
        fee_pari <- swap_fee;

        CallTransferFrom token0_amount _sender _this_address token0_address;

        match fee_pari with
        | Pair zil_fee tokens_fee =>
          direction0 = TokenToZil;
          exact_side0 = ExactInput;
          zil_reserve0_u256 = grow_u128 zil_reserve0;
          token_reserve0_u256 = grow_u128 token_reserve0;

          zil_intermediate_amount_u256 = amount_for
            direction0
            exact_side0
            exact_amount0_u256
            zil_reserve0_u256
            token_reserve0_u256;
          amount_token_u256 = get_fee exact_amount0_u256 tokens_fee;
          tokens_fee_u256 = builtin sub exact_amount0_u256 amount_token_u256;

          tokens_fee_u128 = fall_u256 tokens_fee_u256;

          ReceiveRewards token0_address zero128 tokens_fee_u128;

          match pool1 with
          | Pair zil_reserve1 token_reserve1 =>
            direction1 = ZilToToken;
            exact_side1 = ExactInput;
            zil_reserve1_u256 = grow_u128 zil_reserve1;
            token_reserve1_u256 = grow_u128 token_reserve1;

            calculated_amount_u256 = amount_for
              direction1
              exact_side1
              zil_intermediate_amount_u256
              zil_reserve1_u256
              token_reserve1_u256;

            amount_token0_u256 = get_fee calculated_amount_u256 tokens_fee;
            tokens_fee0_u256 = builtin sub calculated_amount_u256 amount_token0_u256;
            amount_token0_u128 = fall_u256 amount_token0_u256;
            tokens_fee0_u128 = fall_u256 tokens_fee0_u256;
    
            CheckLimits amount_token0_u128 min_token1_amount exact_side1;

            zil_intermediate_amount_u128 = fall_u256 zil_intermediate_amount_u256;
            SwapOptions
              token0_address
              direction0
              exact_side0
              token0_amount
              zil_intermediate_amount_u128
              zil_reserve0
              token_reserve0
              ff;
            SwapOptions
              token1_address
              direction1
              exact_side1
              zil_intermediate_amount_u128
              amount_token0_u128
              zil_reserve1
              token_reserve1
              ff;
            ReceiveRewards token1_address zero128 tokens_fee_u128;
            CallTransfer recipient_address amount_token0_u128 token1_address;
            CallBack
              token0_address
              token1_address
              token0_amount
              amount_token0_u128
              tt
          end
        end
      end
    | None =>
      err = CodePoolMissing;
      ThrowError err
    end
  | None =>
    err = CodePoolMissing;
    ThrowError err
  end
end

transition ClaimRewards(token: ByStr20)
  current_block <- & BLOCKNUMBER;
  CheckBlockTimer current_block;

  some_rewards <- rewards[token];

  match some_rewards with
  | Some pool_rewards =>
    ThrowZero pool_rewards;

    some_total_contributions <- total_contributions[token];
    some_sender_balance <- balances[token][_sender];

    total_contributions_u128 = option_uint128 zero128 some_total_contributions;
    sender_balance_u128 = option_uint128 zero128 some_sender_balance;

    total_contributions_u256 = grow_u128 total_contributions_u128;
    sender_balance_u256 = grow_u128 sender_balance_u128;
    rewards_pool_u256 = grow_u128 pool_rewards;

    percent_u256 = clac_percent
      total_contributions_u256
      sender_balance_u256
      hundred256;

    amount_rewards_u256 = clac_percent hundred256 rewards_pool_u256 percent_u256;
    amount_rewards_u128 = fall_u256 amount_rewards_u256;

    ThrowZero amount_rewards_u128;

    new_rewards_pool = builtin sub pool_rewards amount_rewards_u128;

    e = {
      _eventname: "ClaimedRewards";
      initiator: _sender;
      token: token;
      new_rewards_pool: new_rewards_pool;
      percent: percent_u256;
      amount_rewards: amount_rewards_u128
    };
    event e;

    CallTransfer _sender amount_rewards_u128 token;

    rewards[token] := new_rewards_pool
  | None =>
    err = CodePoolMissing;
    ThrowError err
  end
end
(* user interactions *)


(* admin interactions *)
transition SetFee(zil_fee: Uint256, tokens_fee: Uint256)
  OwnerOnly;
  new_fee = Pair {Uint256 Uint256} zil_fee tokens_fee;
  swap_fee := new_fee
end

transition SetCallBackAddress(addr: ByStr20)
  OwnerOnly;
  callback_addr := addr
end

transition SetRewardsPoolAddress(addr: ByStr20)
  OwnerOnly;
  rewards_pool := addr
end

transition SetNewMinLP(new_min_lp: Uint128)
  OwnerOnly;
  min_lp := new_min_lp
end

transition SetMinBlocksRewards(new_blocks: Int256)
  OwnerOnly;
  min_rewards_blocks := new_blocks
end

transition ReturnFunds()
  OwnerOnly;

  bal <- contract_balance;
  wallet <- owner;

  AddFunds wallet bal
end
(* admin interactions *)


(* operator interactions *)
transition TransferOwnership(new_owner: ByStr20)
  OperatorOnly;

  already_voted <- exists transfer_owner_approvals[new_owner][_sender];
  approvals <- number_approvals;

  match already_voted with
  | True =>
    new_approvals = builtin sub approvals one32;
    number_approvals := new_approvals;
    delete transfer_owner_approvals[new_owner][_sender]
  | False =>
    new_approvals = builtin add approvals one32;
    number_of_operators = list_length_addr operators;
    is_enough = builtin eq number_of_operators new_approvals;

    match is_enough with
    | True =>
      delete transfer_owner_approvals[new_owner];
      number_approvals := zero32;
      owner := new_owner
    | False =>
      number_approvals := new_approvals;
      transfer_owner_approvals[new_owner][_sender] := tt
    end
  end
end
(* operator interactions *)


(* callbacks *)
transition RecipientAcceptTransfer(sender: ByStr20, recipient: ByStr20, amount: Uint128)
end

transition RecipientAcceptTransferFrom(initiator: ByStr20, sender: ByStr20, recipient: ByStr20, amount: Uint128)
end

transition TransferFromSuccessCallBack(initiator: ByStr20, sender: ByStr20, recipient: ByStr20, amount: Uint128)
end

transition TransferSuccessCallBack(sender: ByStr20, recipient: ByStr20, amount: Uint128)
end
(* callbacks *)
