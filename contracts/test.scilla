scilla_version 0

import BoolUtils IntUtils

library PaySwapLib

type Denom =
  | Zil
  | Token of ByStr20 (* token address / hash *)
type Coins = | Coins of Denom Uint128 (* denom, amount *)
type Pool = | Pool of Uint128 Uint128 (* x, y = zil reserve, token reserve *)
type SwapDirection = | ZilToToken | TokenToZil
type ExactSide = | ExactInput | ExactOutput
type Swap = | Swap of (Option Pool) SwapDirection ExactSide Uint128 (Option Uint128) Uint256 (* exact amt, limit amt, after fee amt *)

type ResultOrError =
 | Result of Pool Uint128 (* unwrapped pool, calculated amount *)
 | Error of String

let zero = Uint128 0
let one = Uint128 1
let min_liquidity = Uint128 1000000000000000 (* 1000 ZIL *)
let fee_denom = Uint256 10000 (* fee denominated in basis points (1 b.p. = 0.01%) *)
let zero_address = 0x0000000000000000000000000000000000000000
let zil = Zil
let true = True

let oneMsg : Message -> List Message =
  fun (msg : Message) =>
    let nil_msg = Nil {Message} in
    Cons {Message} msg nil_msg

let unwrapOrZero : Option Uint128 -> Uint128 =
  fun (wrapped : Option Uint128) =>
    match wrapped with
    | None => zero
    | Some x => x
    end

let grow : Uint128 -> Uint256 =
  fun (var : Uint128) =>
    let maybe_big = builtin to_uint256 var in
    match maybe_big with
    | Some big => big
    | None => Uint256 0 (* should never happen *)
    end

(* computes the amount of the fraction x / d that is in y *)
let frac : Uint128 -> Uint128 -> Uint128 -> Uint128  =
  fun (d : Uint128) =>
  fun (x : Uint128) =>
  fun (y : Uint128) =>
    let big_x = grow x in
    let big_y = grow y in
    let big_d = grow d in
    let d_times_y = builtin mul big_d big_y in
    let d_times_y_over_x = builtin div d_times_y big_x in
    let maybe = builtin to_uint128 d_times_y_over_x in
    match maybe with
    | None => builtin sub zero one (* throw on overflow by computing -1 in uint *)
    | Some r => r
    end

(* computes the output that should be taken from the output reserve
   when the given input amount is added to the input reserve *)
let outputFor : Uint128 -> Uint128 -> Uint128 -> Uint256 -> Uint128 =
  fun (input_amount_u128 : Uint128) =>
  fun (input_reserve_u128 : Uint128) =>
  fun (output_reserve_u128 : Uint128) =>
  fun (after_fee : Uint256) =>
    let input_amount = grow input_amount_u128 in
    let input_reserve = grow input_reserve_u128 in
    let output_reserve = grow output_reserve_u128 in
    let input_amount_after_fee = builtin mul input_amount after_fee in
    let numerator = builtin mul input_amount_after_fee output_reserve in
    let denominator =
      let d1 = builtin mul input_reserve fee_denom in
        builtin add d1 input_amount_after_fee in
    let result = builtin div numerator denominator in
    let maybe = builtin to_uint128 result in
    match maybe with
    | None => builtin sub zero one (* throw on overflow by computing -1 in uint *)
    | Some r => r
    end

(* computes the input that should be given to the input reserve
   when the given output amount is removed from the output reserve *)
let inputFor : Uint128 -> Uint128 -> Uint128 -> Uint256 -> Uint128 =
  fun (output_amount_u128 : Uint128) =>
  fun (input_reserve_u128 : Uint128) =>
  fun (output_reserve_u128 : Uint128) =>
  fun (after_fee : Uint256) =>
    let output_amount = grow output_amount_u128 in
    let input_reserve = grow input_reserve_u128 in
    let output_reserve = grow output_reserve_u128 in
    let numerator =
      let n1 = builtin mul input_reserve output_amount in
      builtin mul n1 fee_denom in
    let denominator =
      let d1 = builtin sub output_reserve output_amount in
      builtin mul d1 after_fee in
    let result = builtin div numerator denominator in
    let maybe = builtin to_uint128 result in
    match maybe with
    | None => builtin sub zero one (* throw on overflow by computing -1 in uint *)
    | Some r => r
    end

(* computes the corresponding input or output amount for
   the given exact output or input amount, pool, and direction *)
let amountFor : Pool -> SwapDirection -> ExactSide -> Uint128 -> Uint256 -> Uint128 =
  fun (pool : Pool) =>
  fun (direction : SwapDirection) =>
  fun (exact_side : ExactSide) =>
  fun (exact_amount : Uint128) =>
  fun (after_fee : Uint256) =>
    match pool with
    | Pool zil_reserve token_reserve =>
      let calc = fun (exact: ExactSide) =>
        match exact with
        | ExactInput => outputFor
        | ExactOutput => inputFor
        end in
      match direction with
      | ZilToToken => calc exact_side exact_amount zil_reserve token_reserve after_fee
      | TokenToZil => calc exact_side exact_amount token_reserve zil_reserve after_fee
      end
    end

(* checks whether the result amount is within the user provided
   limit amount, which is dependent on whether the output or input
   result was the one being computed *)
let withinLimits : Uint128 -> Option Uint128 -> ExactSide -> Bool =
  fun (result_amount : Uint128) =>
  fun (maybe_limit_amount : Option Uint128) =>
  fun (exact_side : ExactSide) =>
    match maybe_limit_amount with
    | None => True
    | Some limit_amount =>
      match exact_side with
      | ExactInput =>
        (* we are given an exact input and are computing the output,
           which should be greater or equal to the limit *)
        uint128_ge result_amount limit_amount
      | ExactOutput =>
        (* we are given an exact output and are computing the input,
           which should be lower or equal to the limit *)
        uint128_ge limit_amount result_amount
      end
    end

(* computes the resultant amount for the given swap *)
let resultFor : Swap -> ResultOrError =
  fun (swap : Swap) =>
    match swap with
    | Swap maybe_pool direction exact_side exact_amount maybe_limit_amount after_fee =>
      match maybe_pool with
      | None => let e = "MissingPool" in Error e
      | Some pool =>
        let amount = amountFor pool direction exact_side exact_amount after_fee in
        let within_limits = withinLimits amount maybe_limit_amount exact_side in
        match within_limits with
        | False => let e = "RequestedRatesCannotBeFulfilled" in Error e
        | True => Result pool amount
        end
      end
    end

(* checks whether the given pool is empty based
   on where either of the token reserve amounts are zero *)
let poolEmpty : Pool -> Bool =
  fun (p : Pool) =>
    match p with
    | Pool x y =>
      let x_empty = builtin lt x one in
      let y_empty = builtin lt y one in
      orb x_empty y_empty
    end

contract PaySwapContract
()

field pools : Map ByStr20 Pool = Emp ByStr20 Pool
field balances : Map ByStr20 (Map ByStr20 Uint128) = Emp ByStr20 (Map ByStr20 Uint128)
field total_contributions : Map ByStr20 Uint128 = Emp ByStr20 Uint128

procedure ThrowIfExpired(deadline_block: BNum)
  current_block <- & BLOCKNUMBER;
  is_not_expired = builtin blt current_block deadline_block;
  match is_not_expired with
  | True =>
  | False => e = { _exception : "TransactionExpired" }; throw e
  end
end

procedure ThrowIfZero(number: Uint128)
  gt_zero = uint128_gt number zero;
  match gt_zero with
  | True =>
  | False => e = { _exception : "InvalidParameter" }; throw e
  end
end

transition AddLiquidity(
  token_address : ByStr20,
  min_contribution_amount : Uint128,
  max_token_amount : Uint128,
  amt : Uint128
)
  ThrowIfZero amt;
  ThrowIfZero max_token_amount;

  token = Token token_address;

  maybe_pool <- pools[token_address];
  match maybe_pool with
  | None =>
    new_pool = Pool amt max_token_amount;
    pools[token_address] := new_pool;
    e1 = { _eventname: "PoolCreated"; pool: token_address };
    event e1;

    balances[token_address][_sender] := amt;
    total_contributions[token_address] := amt;
    e2 = { _eventname: "Mint"; pool: token_address; address: _sender; amount: amt };
    event e2
  | Some pool =>
    match pool with
    | Pool x y => (* zil reserve, token reserve *)

      (* dY = dX * Y / X + 1 *)
      (* dX is always the QA transferred *)
      delta_y = frac amt x y;
      maybe_total_contribution <- total_contributions[token_address];
      total_contribution = unwrapOrZero maybe_total_contribution;
      ThrowIfZero total_contribution;

      (* (amt *  total_contribution) / x *)
      new_contribution = frac amt x total_contribution;
      within_limits =
        let token_lte_max = uint128_le delta_y max_token_amount in
        let contribution_gte_max = uint128_ge new_contribution min_contribution_amount in
        andb token_lte_max contribution_gte_max;
      match within_limits with
      | True =>
      | False => e = { _exception : "RequestedRatesCannotBeFulfilled" ; delta_y: delta_y }; throw e
      end;

      new_pool =
        let new_x = builtin add x amt in
        let new_y = builtin add y delta_y in
        Pool new_x new_y;
      pools[token_address] := new_pool;

      existing_balance <- balances[token_address][_sender];
      match existing_balance with
      | Some b =>
        new_balance = builtin add b new_contribution;
        balances[token_address][_sender] := new_balance
      | None =>
        balances[token_address][_sender] := new_contribution
      end;

      new_total_contribution = builtin add total_contribution new_contribution;
      total_contributions[token_address] := new_total_contribution;

      e = { _eventname: "Mint"; pool: token_address; address: _sender; amount: new_contribution };
      event e
    end
  end
end

