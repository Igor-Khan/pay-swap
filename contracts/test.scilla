scilla_version 0

import BoolUtils IntUtils

library PaySwapLib

type Denom =
  | Zil
  | Token of ByStr20 (* token address / hash *)
type Coins = | Coins of Denom Uint128 (* denom, amount *)
type Pool = | Pool of Uint128 Uint128 (* x, y = zil reserve, token reserve *)
type SwapDirection = | ZilToToken | TokenToZil
type ExactSide = | ExactInput | ExactOutput
type Swap = | Swap of (Option Pool) SwapDirection ExactSide Uint128 (Option Uint128) Uint256 (* exact amt, limit amt, after fee amt *)

type ResultOrError =
 | Result of Pool Uint128 (* unwrapped pool, calculated amount *)
 | Error of String

let zero = Uint128 0
let one = Uint128 1
let min_liquidity = Uint128 1000000000000000 (* 1000 ZIL *)
let fee_denom = Uint256 1 (* fee denominated in basis points (1 b.p. = 0.01%) *)
let zero_address = 0x0000000000000000000000000000000000000000
let zil = Zil
let true = True

let oneMsg : Message -> List Message =
  fun (msg : Message) =>
    let nil_msg = Nil {Message} in
    Cons {Message} msg nil_msg

let unwrapOrZero : Option Uint128 -> Uint128 =
  fun (wrapped : Option Uint128) =>
    match wrapped with
    | None => zero
    | Some x => x
    end

let grow : Uint128 -> Uint256 =
  fun (var : Uint128) =>
    let maybe_big = builtin to_uint256 var in
    match maybe_big with
    | Some big => big
    | None => Uint256 0 (* should never happen *)
    end

(* computes the amount of the fraction x / d that is in y *)
let frac : Uint128 -> Uint128 -> Uint128 -> Uint128  =
  fun (d : Uint128) =>
  fun (x : Uint128) =>
  fun (y : Uint128) =>
    let big_x = grow x in
    let big_y = grow y in
    let big_d = grow d in
    let d_times_y = builtin mul big_d big_y in
    let d_times_y_over_x = builtin div d_times_y big_x in
    let maybe = builtin to_uint128 d_times_y_over_x in
    match maybe with
    | None => builtin sub zero one (* throw on overflow by computing -1 in uint *)
    | Some r => r
    end

(* computes the output that should be taken from the output reserve
   when the given input amount is added to the input reserve *)
let outputFor : Uint128 -> Uint128 -> Uint128 -> Uint256 -> Uint128 =
  fun (input_amount_u128 : Uint128) =>
  fun (input_reserve_u128 : Uint128) =>
  fun (output_reserve_u128 : Uint128) =>
  fun (after_fee : Uint256) =>
    let input_amount = grow input_amount_u128 in
    let input_reserve = grow input_reserve_u128 in
    let output_reserve = grow output_reserve_u128 in
    let input_amount_after_fee = builtin mul input_amount after_fee in
    let numerator = builtin mul input_amount_after_fee output_reserve in
    let denominator =
      let d1 = builtin mul input_reserve fee_denom in
        builtin add d1 input_amount_after_fee in
    let result = builtin div numerator denominator in
    let maybe = builtin to_uint128 result in
    match maybe with
    | None => builtin sub zero one (* throw on overflow by computing -1 in uint *)
    | Some r => r
    end

(* computes the input that should be given to the input reserve
   when the given output amount is removed from the output reserve *)
let inputFor : Uint128 -> Uint128 -> Uint128 -> Uint256 -> Uint128 =
  fun (output_amount_u128 : Uint128) =>
  fun (input_reserve_u128 : Uint128) =>
  fun (output_reserve_u128 : Uint128) =>
  fun (after_fee : Uint256) =>
    let output_amount = grow output_amount_u128 in
    let input_reserve = grow input_reserve_u128 in
    let output_reserve = grow output_reserve_u128 in
    let numerator =
      let n1 = builtin mul input_reserve output_amount in
      builtin mul n1 fee_denom in
    let denominator =
      let d1 = builtin sub output_reserve output_amount in
      builtin mul d1 after_fee in
    let result = builtin div numerator denominator in
    let maybe = builtin to_uint128 result in
    match maybe with
    | None => builtin sub zero one (* throw on overflow by computing -1 in uint *)
    | Some r => r
    end

(* computes the corresponding input or output amount for
   the given exact output or input amount, pool, and direction *)
let amountFor : Pool -> SwapDirection -> ExactSide -> Uint128 -> Uint256 -> Uint128 =
  fun (pool : Pool) =>
  fun (direction : SwapDirection) =>
  fun (exact_side : ExactSide) =>
  fun (exact_amount : Uint128) =>
  fun (after_fee : Uint256) =>
    match pool with
    | Pool zil_reserve token_reserve =>
      let calc = fun (exact: ExactSide) =>
        match exact with
        | ExactInput => outputFor
        | ExactOutput => inputFor
        end in
      match direction with
      | ZilToToken => calc exact_side exact_amount zil_reserve token_reserve after_fee
      | TokenToZil => calc exact_side exact_amount token_reserve zil_reserve after_fee
      end
    end

(* checks whether the result amount is within the user provided
   limit amount, which is dependent on whether the output or input
   result was the one being computed *)
let withinLimits : Uint128 -> Option Uint128 -> ExactSide -> Bool =
  fun (result_amount : Uint128) =>
  fun (maybe_limit_amount : Option Uint128) =>
  fun (exact_side : ExactSide) =>
    match maybe_limit_amount with
    | None => True
    | Some limit_amount =>
      match exact_side with
      | ExactInput =>
        (* we are given an exact input and are computing the output,
           which should be greater or equal to the limit *)
        uint128_ge result_amount limit_amount
      | ExactOutput =>
        (* we are given an exact output and are computing the input,
           which should be lower or equal to the limit *)
        uint128_ge limit_amount result_amount
      end
    end

(* computes the resultant amount for the given swap *)
let resultFor : Swap -> ResultOrError =
  fun (swap : Swap) =>
    match swap with
    | Swap maybe_pool direction exact_side exact_amount maybe_limit_amount after_fee =>
      match maybe_pool with
      | None => let e = "MissingPool" in Error e
      | Some pool =>
        let amount = amountFor pool direction exact_side exact_amount after_fee in
        let within_limits = withinLimits amount maybe_limit_amount exact_side in
        match within_limits with
        | False => let e = "RequestedRatesCannotBeFulfilled" in Error e
        | True => Result pool amount
        end
      end
    end

(* checks whether the given pool is empty based
   on where either of the token reserve amounts are zero *)
let poolEmpty : Pool -> Bool =
  fun (p : Pool) =>
    match p with
    | Pool x y =>
      let x_empty = builtin lt x one in
      let y_empty = builtin lt y one in
      orb x_empty y_empty
    end

contract PaySwapContract
()

field pools : Map ByStr20 Pool = Emp ByStr20 Pool
field balances : Map ByStr20 (Map ByStr20 Uint128) = Emp ByStr20 (Map ByStr20 Uint128)
field total_contributions : Map ByStr20 Uint128 = Emp ByStr20 Uint128
field output_after_fee : Uint256 = Uint256 1

procedure ThrowIfZero(number: Uint128)
  gt_zero = uint128_gt number zero;
  match gt_zero with
  | True =>
  | False => e = { _exception : "InvalidParameter" }; throw e
  end
end

procedure ThrowIfZil(address : ByStr20)
  is_zil = builtin eq address zero_address;
  match is_zil with
  | False =>
  | True => e = { _exception : "InvalidParameter" }; throw e
  end
end

procedure Send(coins : Coins, to_address : ByStr20)
  match coins with
  | Coins denom amount =>
    match denom with
    | Zil =>
      e = {
        _eventname: "AddFunds";
        to: to_address;
        amount: amount
      };
      event e
    | Token token =>
      e = {
        _eventname: "Transfer";
        to: to_address;
        amount: amount;
        token: token
      };
      event e
    end
  end
end

procedure Receive(coins : Coins)
  match coins with
  | Coins denom amount =>
    match denom with
    | Zil =>
      needs_refund = uint128_gt _amount amount;
      accept;
      match needs_refund with
      | True =>
        refund =
          let refund_amount = builtin sub _amount amount in
          Coins zil refund_amount;
        Send refund _sender
      | False => (* do nothing *)
      end
    | Token token =>
      e = {
        _eventname: "TransferFrom";
        token: token;
        from: _sender;
        to: _this_address;
        amount: amount
      };
      event e
    end
  end
end

procedure DoSwap(
  pool : Pool,
  token_address : ByStr20,
  input : Coins,
  output : Coins,
  input_from : ByStr20,
  output_to : ByStr20
)
  match pool with
  | Pool x y => (* zil reserve, token reserve *)

    (* update new pool balances *)
    match input with
    | Coins input_denom input_amount =>
      match output with
      | Coins output_denom output_amount =>
        match input_denom with
        | Zil =>
          new_pool =
            let new_x = builtin add x input_amount in
            let new_y = builtin sub y output_amount in
          Pool new_x new_y;
          pools[token_address] := new_pool
        | Token t =>
          new_pool =
            let new_x = builtin sub x output_amount in
            let new_y = builtin add y input_amount in
          Pool new_x new_y;
          pools[token_address] := new_pool
        end
      end
    end;

    (* do receive / send *)
    sending_from_self = builtin eq input_from _this_address;
    match sending_from_self with
    | True => (* don't do anything on internal send *)
    | False => Receive input (* accept the expected input *)
    end;

    sending_to_self = builtin eq output_to _this_address;
    match sending_to_self with
    | True => (* don't do anything on internal receive *)
    | False => Send output output_to (* send the expected output *)
    end;

    (* emit swap event *)
    e = {
      _eventname: "Swapped";
      pool: token_address; address: _sender;
      input: input; output: output
    };
    event e
  end
end

procedure SwapUsingZIL(
  token_address : ByStr20,
  direction : SwapDirection,
  exact_side : ExactSide,
  exact_amount : Uint128,
  limit_amount : Uint128,
  recipient_address : ByStr20
)
  ThrowIfZero exact_amount;
  ThrowIfZero limit_amount;

  after_fee <- output_after_fee;
  maybe_pool <- pools[token_address];
  result =
    let option_limit_amount = Some {Uint128} limit_amount in
    let swap = Swap maybe_pool direction exact_side exact_amount option_limit_amount after_fee in
    resultFor swap;

  match result with
  | Error msg => e = { _exception : msg }; throw e
  | Result pool calculated_amount =>
    token = Token token_address;
    match exact_side with
    | ExactInput =>
      match direction with
      | ZilToToken =>
        input = Coins zil exact_amount;
        output = Coins token calculated_amount;
        DoSwap pool token_address input output _sender recipient_address
      | TokenToZil =>
        input = Coins token exact_amount;
        output = Coins zil calculated_amount;
        DoSwap pool token_address input output _sender recipient_address
      end
    | ExactOutput =>
      match direction with
      | ZilToToken =>
        input = Coins zil calculated_amount;
        output = Coins token exact_amount;
        DoSwap pool token_address input output _sender recipient_address
      | TokenToZil =>
        input = Coins token calculated_amount;
        output = Coins zil exact_amount;
        DoSwap pool token_address input output _sender recipient_address
      end
    end
  end
end


transition AddLiquidity(
  token_address : ByStr20,
  min_contribution_amount : Uint128,
  max_token_amount : Uint128,
  amount : Uint128
)
  ThrowIfZil token_address;
  ThrowIfZero amount;
  ThrowIfZero max_token_amount;

  token = Token token_address;

  (* accept all zil *)
  zils_in = Coins zil amount;

  maybe_pool <- pools[token_address];
  match maybe_pool with
  | None =>
    tokens_in = Coins token max_token_amount;

    new_pool = Pool amount max_token_amount;
    pools[token_address] := new_pool;
    e1 = { _eventname: "PoolCreated"; pool: token_address };
    event e1;

    balances[token_address][_sender] := amount;
    total_contributions[token_address] := amount;
    e2 = { _eventname: "Mint"; pool: token_address; address: _sender; amount: amount };
    event e2
  | Some pool =>
    match pool with
    | Pool x y => (* zil reserve, token reserve *)
      maybe_total_contribution <- total_contributions[token_address];

      (* dY = dX * Y / X + 1 *)
      (* dX is always the QA transferred *)
      result = frac amount x y;
      delta_y = builtin add result one;
      total_contribution = unwrapOrZero maybe_total_contribution;

      (* (amount *  total_contribution) / x *)
      new_contribution = frac amount x total_contribution;
      within_limits =
        let token_lte_max = uint128_le delta_y max_token_amount in
        let contribution_gte_max = uint128_ge new_contribution min_contribution_amount in
        andb token_lte_max contribution_gte_max;
      match within_limits with
      | True =>
      | False => e = { _exception : "RequestedRatesCannotBeFulfilled" ; delta_y: delta_y }; throw e
      end;

      tokens_in = Coins token delta_y;

      new_pool =
        let new_x = builtin add x amount in
        let new_y = builtin add y delta_y in
        Pool new_x new_y;
      pools[token_address] := new_pool;

      existing_balance <- balances[token_address][_sender];
      match existing_balance with
      | Some b =>
        new_balance = builtin add b new_contribution;
        balances[token_address][_sender] := new_balance
      | None =>
        balances[token_address][_sender] := new_contribution
      end;

      new_total_contribution = builtin add total_contribution new_contribution;
      total_contributions[token_address] := new_total_contribution;

      e = { _eventname: "Mint"; pool: token_address; address: _sender; amount: new_contribution };
      event e
    end
  end
end

transition RemoveLiquidity(
  token_address : ByStr20,
  contribution_amount : Uint128,
  min_zil_amount : Uint128,
  min_token_amount : Uint128
)
  ThrowIfZero contribution_amount;
  ThrowIfZero min_zil_amount;
  ThrowIfZero min_token_amount;

  token = Token token_address;

  maybe_pool <- pools[token_address];
  match maybe_pool with
  | None => e = { _exception : "MissingPool" }; throw e
  | Some pool =>
    match pool with
    | Pool x y => (* zil reserve, token reserve *)
      maybe_total_contribution <- total_contributions[token_address];
      total_contribution = unwrapOrZero maybe_total_contribution;

      zil_amount = frac contribution_amount total_contribution x;
      token_amount = frac contribution_amount total_contribution y;
      within_limits =
        let zil_ok = uint128_ge zil_amount min_zil_amount in
        let token_ok = uint128_ge token_amount min_token_amount in
        andb zil_ok token_ok;
      match within_limits with
      | True =>
      | False => e = { _exception : "RequestedRatesCannotBeFulfilled" }; throw e
      end;

      existing_balance <- balances[token_address][_sender];
      b = unwrapOrZero existing_balance;
      new_balance = builtin sub b contribution_amount;
      new_total_contribution = builtin sub total_contribution contribution_amount;
      new_pool =
        let new_x = builtin sub x zil_amount in
        let new_y = builtin sub y token_amount in
        Pool new_x new_y;

      (* Improve *)
      is_pool_now_empty = poolEmpty new_pool;
      match is_pool_now_empty with
      | True =>
        (* clear pool entries when there is no more liquidity *)
        delete pools[token_address];
        delete balances[token_address];
        delete total_contributions[token_address]
      | False =>
        pools[token_address] := new_pool;
        balances[token_address][_sender] := new_balance;
        total_contributions[token_address] := new_total_contribution
      end;

      zils_out = Coins zil zil_amount;
      tokens_out = Coins token token_amount;

      e = { _eventname: "Burnt"; pool: token_address; address: _sender; amount: contribution_amount };
      event e
    end
  end
end

transition SwapExactZILForTokens(
  token_address : ByStr20,
  min_token_amount : Uint128,
  amount : Uint128,
  recipient_address : ByStr20
)
  direction = ZilToToken;
  exact_side = ExactInput;
  exact_amount = amount;
  limit_amount = min_token_amount;

  SwapUsingZIL
    token_address
    direction
    exact_side
    exact_amount
    limit_amount
    recipient_address
end

transition SwapExactTokensForZIL(
  token_address : ByStr20,
  token_amount : Uint128,
  min_zil_amount : Uint128,
  recipient_address : ByStr20
)
  direction = TokenToZil;
  exact_side = ExactInput;
  exact_amount = token_amount;
  limit_amount = min_zil_amount;

  SwapUsingZIL
    token_address
    direction
    exact_side
    exact_amount
    limit_amount
    recipient_address
end
