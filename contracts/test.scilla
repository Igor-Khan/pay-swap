scilla_version 0

import BoolUtils IntUtils

library PaySwapLib

type Denom =
  | Zil
  | Token of ByStr20 (* token address / hash *)
type Coins = | Coins of Denom Uint128 (* denom, amount *)
type Pool = | Pool of Uint128 Uint128 (* x, y = zil reserve, token reserve *)
type SwapDirection = | ZilToToken | TokenToZil
type ExactSide = | ExactInput | ExactOutput
type Swap = | Swap of (Option Pool) SwapDirection ExactSide Uint128 (Option Uint128) Uint256 (* exact amt, limit amt, after fee amt *)

type ResultOrError =
 | Result of Pool Uint128 (* unwrapped pool, calculated amount *)
 | Error of String

let zero = Uint128 0
let one = Uint128 1
let min_liquidity = Uint128 1000000000000000 (* 1000 ZIL *)
let fee_denom = Uint256 10000 (* fee denominated in basis points (1 b.p. = 0.01%) *)
let zero_address = 0x0000000000000000000000000000000000000000
let zil = Zil
let true = True

let oneMsg : Message -> List Message =
  fun (msg : Message) =>
    let nil_msg = Nil {Message} in
    Cons {Message} msg nil_msg

let unwrapOrZero : Option Uint128 -> Uint128 =
  fun (wrapped : Option Uint128) =>
    match wrapped with
    | None => zero
    | Some x => x
    end

let grow : Uint128 -> Uint256 =
  fun (var : Uint128) =>
    let maybe_big = builtin to_uint256 var in
    match maybe_big with
    | Some big => big
    | None => Uint256 0 (* should never happen *)
    end

(* computes the amount of the fraction x / d that is in y *)
let frac : Uint128 -> Uint128 -> Uint128 -> Uint128  =
  fun (d : Uint128) =>
  fun (x : Uint128) =>
  fun (y : Uint128) =>
    let big_x = grow x in
    let big_y = grow y in
    let big_d = grow d in
    let d_times_y = builtin mul big_d big_y in
    let d_times_y_over_x = builtin div d_times_y big_x in
    let maybe = builtin to_uint128 d_times_y_over_x in
    match maybe with
    | None => builtin sub zero one (* throw on overflow by computing -1 in uint *)
    | Some r => r
    end

(* computes the output that should be taken from the output reserve
   when the given input amount is added to the input reserve *)
let outputFor : Uint128 -> Uint128 -> Uint128 -> Uint256 -> Uint128 =
  fun (input_amount_u128 : Uint128) =>
  fun (input_reserve_u128 : Uint128) =>
  fun (output_reserve_u128 : Uint128) =>
  fun (after_fee : Uint256) =>
    let input_amount = grow input_amount_u128 in
    let input_reserve = grow input_reserve_u128 in
    let output_reserve = grow output_reserve_u128 in
    let input_amount_after_fee = builtin mul input_amount after_fee in
    let numerator = builtin mul input_amount_after_fee output_reserve in
    let denominator =
      let d1 = builtin mul input_reserve fee_denom in
        builtin add d1 input_amount_after_fee in
    let result = builtin div numerator denominator in
    let maybe = builtin to_uint128 result in
    match maybe with
    | None => builtin sub zero one (* throw on overflow by computing -1 in uint *)
    | Some r => r
    end

(* computes the input that should be given to the input reserve
   when the given output amount is removed from the output reserve *)
let inputFor : Uint128 -> Uint128 -> Uint128 -> Uint256 -> Uint128 =
  fun (output_amount_u128 : Uint128) =>
  fun (input_reserve_u128 : Uint128) =>
  fun (output_reserve_u128 : Uint128) =>
  fun (after_fee : Uint256) =>
    let output_amount = grow output_amount_u128 in
    let input_reserve = grow input_reserve_u128 in
    let output_reserve = grow output_reserve_u128 in
    let numerator =
      let n1 = builtin mul input_reserve output_amount in
      builtin mul n1 fee_denom in
    let denominator =
      let d1 = builtin sub output_reserve output_amount in
      builtin mul d1 after_fee in
    let result = builtin div numerator denominator in
    let maybe = builtin to_uint128 result in
    match maybe with
    | None => builtin sub zero one (* throw on overflow by computing -1 in uint *)
    | Some r => r
    end

(* computes the corresponding input or output amount for
   the given exact output or input amount, pool, and direction *)
let amountFor : Pool -> SwapDirection -> ExactSide -> Uint128 -> Uint256 -> Uint128 =
  fun (pool : Pool) =>
  fun (direction : SwapDirection) =>
  fun (exact_side : ExactSide) =>
  fun (exact_amount : Uint128) =>
  fun (after_fee : Uint256) =>
    match pool with
    | Pool zil_reserve token_reserve =>
      let calc = fun (exact: ExactSide) =>
        match exact with
        | ExactInput => outputFor
        | ExactOutput => inputFor
        end in
      match direction with
      | ZilToToken => calc exact_side exact_amount zil_reserve token_reserve after_fee
      | TokenToZil => calc exact_side exact_amount token_reserve zil_reserve after_fee
      end
    end

(* checks whether the result amount is within the user provided
   limit amount, which is dependent on whether the output or input
   result was the one being computed *)
let withinLimits : Uint128 -> Option Uint128 -> ExactSide -> Bool =
  fun (result_amount : Uint128) =>
  fun (maybe_limit_amount : Option Uint128) =>
  fun (exact_side : ExactSide) =>
    match maybe_limit_amount with
    | None => True
    | Some limit_amount =>
      match exact_side with
      | ExactInput =>
        (* we are given an exact input and are computing the output,
           which should be greater or equal to the limit *)
        uint128_ge result_amount limit_amount
      | ExactOutput =>
        (* we are given an exact output and are computing the input,
           which should be lower or equal to the limit *)
        uint128_ge limit_amount result_amount
      end
    end

(* computes the resultant amount for the given swap *)
let resultFor : Swap -> ResultOrError =
  fun (swap : Swap) =>
    match swap with
    | Swap maybe_pool direction exact_side exact_amount maybe_limit_amount after_fee =>
      match maybe_pool with
      | None => let e = "MissingPool" in Error e
      | Some pool =>
        let amount = amountFor pool direction exact_side exact_amount after_fee in
        let within_limits = withinLimits amount maybe_limit_amount exact_side in
        match within_limits with
        | False => let e = "RequestedRatesCannotBeFulfilled" in Error e
        | True => Result pool amount
        end
      end
    end

(* checks whether the given pool is empty based
   on where either of the token reserve amounts are zero *)
let poolEmpty : Pool -> Bool =
  fun (p : Pool) =>
    match p with
    | Pool x y =>
      let x_empty = builtin lt x one in
      let y_empty = builtin lt y one in
      orb x_empty y_empty
    end

contract PaySwapContract
()

field pools : Map ByStr20 Pool = Emp ByStr20 Pool


