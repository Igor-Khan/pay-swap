scilla_version 0

import IntUtils BoolUtils ListUtils

library DragonDexLib

type Error =
  | CodeNotContractOwner
  | CodePoolMissing
  | CodeNotWithin
  | CodeCannotBeZero
  | CodeRatesCannotBeFulfilled
  | CodeNotOperator
  | CodeTransactionExpired
  | CodeEmptyAddress
  | CodeMinLP
  | CodeSameAddress

type Denom =
  | Zil
  | Token

type SwapDirection =
  | ZilToToken (* make swap ZIL to token type *)
  | TokenToZil (* make swap token to ZIL type *)


let zero_address = 0x0000000000000000000000000000000000000000

let one128 = Uint128 1

let zero128 = Uint128 0
let zero256 = Uint256 0

let tt = True
let ff = False

let zil_denom = Zil
let zrc_denom = Token

let one_msg = 
  fun (msg : Message) => 
    let nil_msg = Nil {Message} in
      Cons {Message} msg nil_msg

let make_error =
  fun (result : Error) =>
    match result with
    | CodeNotContractOwner =>
      {
        _exception: "Sender is not contract owner";
        code: Int32 -1
      }
    | CodePoolMissing =>
      {
        _exception: "Pool is missing";
        code: Int32 -2
      }
    | CodeNotWithin =>
      {
        _exception: "Amount is not within";
        code: Int32 -3
      }
    | CodeCannotBeZero =>
      {
        _exception: "Value cannot be zero";
        code: Int32 -4
      }
    | CodeRatesCannotBeFulfilled =>
      {
        _exception: "Requested rates cannot be fulfilled";
        code: Int32 -5
      }
    | CodeNotOperator =>
      {
        _exception: "Sender is not operator";
        code: Int32 -6
      }
    | CodeTransactionExpired =>
      {
        _exception: "Deadline blocknumber is expired";
        code: Int32 -7
      }
    | CodeEmptyAddress =>
      {
        _exception: "Incorrect address";
        code: Int32 -8
      }
    | CodeMinLP =>
      {
        _exception: "LP less then min";
        code: Int32 -9
      }
    | CodeSameAddress =>
      {
        _exception: "Input addresses are same";
        code: Int32 -10
      }
    end

let option_value =
  tfun 'A =>
  fun (default: 'A) =>
  fun (opt_val: Option 'A) =>
    match opt_val with
    | Some v => v
    | None => default
    end


let option_uint128 = @option_value Uint128


let grow_u128: Uint128 -> Uint256 =
  fun (v : Uint128) =>
    let some_big = builtin to_uint256 v in
    match some_big with
    | Some big => big
    | None => zero256 (* should never happen *)
    end

let fall_u256: Uint256 -> Uint128 =
  fun (v : Uint256) =>
    let some_u128 = builtin to_uint128 v in
    match some_u128 with
    | Some u => u
    | None => zero128 (* should never happen *)
    end

(* computes the amount of the fraction x / d that is in y *)
let fraction: Uint256 -> Uint256 -> Uint256 -> Uint256 =
fun (d: Uint256) =>
fun (x: Uint256) =>
fun (y: Uint256) =>
  let d_times_y = builtin mul d y in
    builtin div d_times_y x

(* computes the output that should be taken from the output reserve
  when the given input amount is added to the input reserve *)
let output_for: Uint256 -> Uint256 -> Uint256 -> Uint256 =
  fun (input_amount: Uint256) =>
  fun (input_reserve: Uint256) =>
  fun (output_reserve: Uint256) =>
    let numerator = builtin mul input_amount output_reserve in
    let denominator = builtin add input_reserve input_amount in
      builtin div numerator denominator

(* computes the corresponding input or output amount for
  the given exact output or input amount, pool, and direction *)
let amount_for: SwapDirection -> Uint256 -> Uint256 -> Uint256 -> Uint256 =
  fun (direction: SwapDirection) =>
  fun (exact_amount: Uint256) =>
  fun (zil_reserve: Uint256) =>
  fun (token_reserve: Uint256) =>
    match direction with
    | ZilToToken => output_for exact_amount zil_reserve token_reserve
    | TokenToZil => output_for exact_amount token_reserve zil_reserve
    end

let check_within_limits =
  fun (amount: Uint128) =>
  fun (max_token_amount: Uint128) =>
  fun (new_contribution: Uint128) =>
  fun (min_contribution_amount: Uint128) =>
    let token_lte_max = uint128_le amount max_token_amount in
    let contribution_gte_max = uint128_ge new_contribution min_contribution_amount in
      andb token_lte_max contribution_gte_max


let pool_from_denom =
  fun (denom: Denom) =>
  fun (input_amount: Uint128) =>
  fun (output_amount: Uint128) =>
  fun (x: Uint128) =>
  fun (y: Uint128) =>
    match denom with
    | Zil =>
      let new_x = builtin add x input_amount in
      let new_y = builtin sub y output_amount in
        Pair {Uint128 Uint128} new_x new_y
    | Token =>
      let new_x = builtin sub x output_amount in
      let new_y = builtin add y input_amount in
        Pair {Uint128 Uint128} new_x new_y
    end

let is_empty_pool =
  fun (x: Uint128) =>
  fun (y: Uint128) =>
    let x_empty = builtin lt x one128 in
    let y_empty = builtin lt y one128 in
      orb x_empty y_empty


contract DragonDexContract
()


(* POOL token -> Pari{zil_reserve, token_reserve} *)
field pools: Map ByStr20 (Pair Uint128 Uint128) = Emp ByStr20 (Pair Uint128 Uint128)

(* token -> full zil_reserve amount *)
field total_contributions: Map ByStr20 Uint128 = Emp ByStr20 Uint128

(* token -> _sender -> started_zil_reserve *)
field balances: Map ByStr20 (Map ByStr20 Uint128) = Emp ByStr20 (Map ByStr20 Uint128)

(* fee for each swap - zil_fee, token_fee *)
field swap_fee: Uint256 = zero256

(* Min number zil for LP providers. *)
field min_lp: Uint128 = Uint128 1


procedure ThrowError(err : Error)
  e = make_error err;
  throw e
end

(* EVENTS *)
procedure emitMintPool(token_address: ByStr20, address: ByStr20, amount: Uint128)
  e = {
    _eventname: "Mint";
    pool: token_address;
    address: address;
    amount: amount
  };
  event e
end
(* EVENTS *)

(* Checkers *)
procedure ThrowZero(v: Uint128)
  is_zero = builtin eq v zero128;
  match is_zero with
  | False =>
  | True =>
    err = CodeCannotBeZero;
    ThrowError err
  end
end

procedure ThrowIfSameAddress(address1: ByStr20, address2: ByStr20)
  is_same = builtin eq address1 address2;
  match is_same with
  | False =>
  | True =>
    err = CodeSameAddress;
    ThrowError err
  end
end

procedure CheckMinLP(lp: Uint128)
  min <- min_lp;
  is_min_lp = uint128_ge min lp;
  
  match is_min_lp with
  | True =>
    err = CodeMinLP;
    ThrowError err
  | False =>
  end
end

procedure ThrowExpired(deadline_block: BNum, current_block: BNum)
  is_not_expired = builtin blt current_block deadline_block;
  match is_not_expired with
  | True =>
  | False =>
    err = CodeTransactionExpired;
    ThrowError err
  end
end

procedure ThrowZeroAddress(address: ByStr20)
  is_zil = builtin eq address zero_address;
  match is_zil with
  | False =>
  | True =>
    err = CodeEmptyAddress;
    ThrowError err
  end
end

procedure CheckLimits(
  amount: Uint128,
  limit: Uint128
)
  (* we are given an exact input and are computing the output,
    which should be greater or equal to the limit *)
  is_within_limits = uint128_ge amount limit;

  match is_within_limits with
  | False =>
    err = CodeRatesCannotBeFulfilled;
    ThrowError err
  | True =>
  end
end
(* Checkers *)

(* iterations *)
procedure CallBack(
  input_token: ByStr20,
  output_output: ByStr20,
  input_amount: Uint128,
  output_amount: Uint128,
  callback: Bool
)
  match callback with
  | True =>
  | False =>
  end
end

procedure MakeSwap(
  token_address: ByStr20,
  input_amount: Uint128,
  output_amount: Uint128,
  denom: Denom,
  zil_reserve: Uint128,
  token_reserve: Uint128
)
  new_pool = pool_from_denom
    denom
    input_amount
    output_amount
    zil_reserve
    token_reserve;
  pools[token_address] := new_pool;

  e = {
    _eventname: "Swapped";
    token: token_address;
    address: _sender;
    input: input_amount;
    output: output_amount
  };
  event e
end

procedure SwapOptions(
  token_address: ByStr20,
  direction: SwapDirection,
  exact_amount: Uint128,
  calculated_amount: Uint128,
  zil_reserve: Uint128,
  token_reserve: Uint128,
  callback: Bool
)
  match direction with
  | ZilToToken =>
    MakeSwap
      token_address
      exact_amount
      calculated_amount
      zil_denom
      zil_reserve
      token_reserve;
    CallBack
      zero_address
      token_address
      exact_amount
      calculated_amount
      callback
  | TokenToZil =>
    MakeSwap
      token_address
      exact_amount
      calculated_amount
      zrc_denom
      zil_reserve
      token_reserve;
    CallBack
      token_address
      zero_address
      exact_amount
      calculated_amount
      callback
  end
end

procedure SwapZIL(
  token_address: ByStr20,
  direction: SwapDirection,
  pool: Pair Uint128 Uint128,
  exact_amount: Uint128,
  limit_amount: Uint128,
  recipient_address: ByStr20
)
  exact_amount_u256 = grow_u128 exact_amount;

  match pool with
  | Pair zil_reserve token_reserve =>
    zil_reserve_u256 = grow_u128 zil_reserve;
    token_reserve_u256 = grow_u128 token_reserve;

    calculated_amount_u256 = amount_for
      direction
      exact_amount_u256
      zil_reserve_u256
      token_reserve_u256;
    calculated_amount_u128 = fall_u256 calculated_amount_u256;

    CheckLimits calculated_amount_u128 limit_amount;
    SwapOptions
      token_address
      direction
      exact_amount
      calculated_amount_u128
      zil_reserve
      token_reserve
      tt
    (* TODO: add recieve rewards *)
    (* TODO: add CallTransfer *)
  end
end

procedure SwapTokens(
  pool0: Pair Uint128 Uint128,
  pool1: Pair Uint128 Uint128,
  token0_address: ByStr20,
  token1_address: ByStr20,
  exact_amount: Uint128,
  limit_amount: Uint128,
  recipient_address: ByStr20
)
  direction0 = TokenToZil;
  direction1 = ZilToToken;

  exact_amount0_u256 = grow_u128 exact_amount;

  match pool0 with
  | Pair zil_reserve0 token_reserve0 =>
    zil_reserve0_u256 = grow_u128 zil_reserve0;
    token_reserve0_u256 = grow_u128 token_reserve0;

    zil_intermediate_amount_u256 = amount_for
      direction0
      exact_amount0_u256
      zil_reserve0_u256
      token_reserve0_u256;
    zil_intermediate_amount_u128 = fall_u256 zil_intermediate_amount_u256;

    (* TODO: add fee *)

    match pool1 with
    | Pair zil_reserve1 token_reserve1 =>
      zil_reserve1_u256 = grow_u128 zil_reserve1;
      token_reserve1_u256 = grow_u128 token_reserve1;

      calculated_amount_u256 = amount_for
        direction1
        zil_intermediate_amount_u256
        zil_reserve1_u256
        token_reserve1_u256;
      calculated_amount_u128 = fall_u256 calculated_amount_u256;

      CheckLimits calculated_amount_u128 limit_amount;

      SwapOptions
        token0_address
        direction0
        exact_amount
        zil_intermediate_amount_u128
        zil_reserve0
        token_reserve0
        ff;
      SwapOptions
        token1_address
        direction1
        zil_intermediate_amount_u128
        calculated_amount_u128
        zil_reserve1
        token_reserve1
        ff;
      (* TODO: add CallTransfer *)
      CallBack
        token0_address
        token1_address
        exact_amount
        limit_amount
        tt
    end
  end
end
(* iterations *)


(* user interactions *)
transition AddLiquidity(
  token_address : ByStr20,
  min_contribution_amount : Uint128,
  max_token_amount : Uint128,
  deadline_block : BNum
)
  current_block <- & BLOCKNUMBER;

  ThrowExpired deadline_block current_block;
  ThrowZeroAddress token_address;
  ThrowZero max_token_amount;

  some_pool <- pools[token_address];

  match some_pool with
  | None =>
    CheckMinLP _amount;
    (* TODO: add transfer from *)
    (* TODO: add accept *)
    (* INIT Pool *)
    new_pool = Pair {Uint128 Uint128} _amount max_token_amount;

    pools[token_address] := new_pool;
    balances[token_address][_sender] := _amount;
    total_contributions[token_address] := _amount;

    (* TODO: add callback *)

    pool_event = {
      _eventname: "PoolCreated";
      pool: token_address
    };
    event pool_event;
    emitMintPool token_address _sender _amount
  | Some pool =>
    match pool with
    | Pair zil_reserve token_reserve =>
      some_total_contribution <- total_contributions[token_address];

      total_contribution = option_uint128 zero128 some_total_contribution;

      total_contribution_u256 = grow_u128 total_contribution;
      amount_u256 = grow_u128 _amount;
      zil_reserve_u256 = grow_u128 zil_reserve;
      token_reserve_u256 = grow_u128 token_reserve;

      (* dY = dX * Y / X *)
      (* dX is always the QA transferred *)
      result_u256 = fraction amount_u256 zil_reserve_u256 token_reserve_u256;
      result_u128 = fall_u256 result_u256;

      (* (_amount *  total_contribution) / x *)
      new_contribution_u256 = fraction amount_u256 zil_reserve_u256 total_contribution_u256;
      new_contribution_u128 = fall_u256 new_contribution_u256;

      is_within_limits = check_within_limits
        result_u128
        max_token_amount
        new_contribution_u128
        min_contribution_amount;

      match is_within_limits with
      | True =>
      | False =>
        err = CodeNotWithin;
        ThrowError err
      end;

      (* TODO: add TransferFrom *)
      (* TODO: add accept ZILs *)

      new_x = builtin add zil_reserve _amount;
      new_y = builtin add token_reserve result_u128;
      new_pool = Pair {Uint128 Uint128} new_x new_y;
      pools[token_address] := new_pool;

      (* TODO: add callback *)

      existing_balance <- balances[token_address][_sender];

      match existing_balance with
      | Some balance =>
        new_balance = builtin add balance new_contribution_u128;
        balances[token_address][_sender] := new_balance
      | None =>
        balances[token_address][_sender] := new_contribution_u128
      end;

      new_total_contribution = builtin add total_contribution new_contribution_u128;
      total_contributions[token_address] := new_total_contribution;

      emitMintPool token_address _sender new_contribution_u128
    end
  end
end

transition RemoveLiquidity(
  token_address: ByStr20,
  contribution_amount: Uint128,
  min_zil_amount: Uint128,
  min_token_amount: Uint128,
  deadline_block: BNum
)
  current_block <- & BLOCKNUMBER;

  ThrowExpired deadline_block current_block;
  ThrowZero contribution_amount;
  ThrowZero min_zil_amount;
  ThrowZero min_token_amount;

  some_pool <- pools[token_address];

  match some_pool with
  | Some pool =>
    match pool with
    | Pair zil_reserve token_reserve =>
      some_total_contribution <- total_contributions[token_address];

      total_contribution_u128 = option_uint128 zero128 some_total_contribution;

      ThrowZero total_contribution_u128;

      zil_reserve_u256 = grow_u128 zil_reserve;
      token_reserve_u256 = grow_u128 token_reserve;

      contribution_amount_u256 = grow_u128 contribution_amount;
      total_contribution_u256 = grow_u128 total_contribution_u128;

      zil_amount_u256 = fraction contribution_amount_u256 total_contribution_u256 zil_reserve_u256;
      token_amount_u256 = fraction contribution_amount_u256 total_contribution_u256 token_reserve_u256;

      zil_amount_u128 = fall_u256 zil_amount_u256;
      token_amount_u128 = fall_u256 token_amount_u256;

      is_within_limits =
        let zil_ok = uint128_ge zil_amount_u128 min_zil_amount in
        let token_ok = uint128_ge token_amount_u128 min_token_amount in
          andb zil_ok token_ok;

      match is_within_limits with
      | True =>
      | False =>
        err = CodeNotWithin;
        ThrowError err
      end;

      some_existing_balance <- balances[token_address][_sender];
      
      existing_balance = option_uint128 zero128 some_existing_balance;

      new_balance = builtin sub existing_balance contribution_amount;
      new_total_contribution = builtin sub total_contribution_u128 contribution_amount;

      new_x = builtin sub zil_reserve zil_amount_u128;
      new_y = builtin sub token_reserve token_amount_u128;
      is_empty_pool = is_empty_pool new_x new_y;

      match is_empty_pool with
      | True =>
        (* clear pool entries when there is no more liquidity *)
        delete pools[token_address];
        delete balances[token_address];
        delete total_contributions[token_address]
      | False =>
        new_pool = Pair {Uint128 Uint128} new_x new_y;

        pools[token_address] := new_pool;
        balances[token_address][_sender] := new_balance;
        total_contributions[token_address] := new_total_contribution
      end;

      (* TODO: CallTransfer _sender token_amount_u128 token_address; *)
      (* TODO: AddFunds _sender zil_amount_u128; *)
      (* TODO: RemoveLPCallBack zil_amount_u128 token_amount_u128; *)

      e = {
        _eventname: "Burnt";
        pool: token_address;
        address: _sender;
        amount: contribution_amount
      };
      event e
    end
  | None =>
    err = CodePoolMissing;
    ThrowError err
  end
end

transition SwapExactZILForTokens(
  token_address : ByStr20,
  min_token_amount : Uint128,
  deadline_block : BNum,
  recipient_address : ByStr20
)
  current_block <- & BLOCKNUMBER;

  ThrowExpired deadline_block current_block;
  ThrowZero _amount;
  ThrowZero min_token_amount;

  some_pool <- pools[token_address];

  match some_pool with
  | Some pool =>
    direction = ZilToToken;

    (* TODO: add accept *)

    SwapZIL
      token_address
      direction
      pool
      _amount
      min_token_amount
      recipient_address
  | None =>
    err = CodePoolMissing;
    ThrowError err
  end
end

transition SwapExactTokensForZIL(
  token_address: ByStr20,
  token_amount: Uint128,
  min_zil_amount: Uint128,
  deadline_block: BNum,
  recipient_address: ByStr20
)
  current_block <- & BLOCKNUMBER;

  ThrowExpired deadline_block current_block;
  ThrowZero token_amount;
  ThrowZero min_zil_amount;
  ThrowZeroAddress recipient_address;

  some_pool <- pools[token_address];

  match some_pool with
  | Some pool =>
    direction = TokenToZil;

    SwapZIL
      token_address
      direction
      pool
      token_amount
      min_zil_amount
      recipient_address
  | None =>
    err = CodePoolMissing;
    ThrowError err
  end
end

transition SwapExactTokensForTokens(
  token0_address: ByStr20,
  token1_address: ByStr20,
  token0_amount: Uint128,
  min_token1_amount: Uint128,
  deadline_block: BNum,
  recipient_address: ByStr20
)
  current_block <- & BLOCKNUMBER;

  ThrowExpired deadline_block current_block;
  ThrowZero token0_amount;
  ThrowZero min_token1_amount;
  ThrowZeroAddress recipient_address;
  ThrowIfSameAddress token0_address token1_address;

  some_pool0 <- pools[token0_address];
  some_pool1 <- pools[token1_address];

  match some_pool0 with
  | Some pool0 =>
    match some_pool1 with
    | Some pool1 =>
      (* TODO: add CallTransferFrom *)
      SwapTokens
        pool0 pool1
        token0_address token1_address
        token0_amount min_token1_amount
        recipient_address
    | None =>
      err = CodePoolMissing;
      ThrowError err
    end
  | None =>
    err = CodePoolMissing;
    ThrowError err
  end
end
(* user interactions *)
