scilla_version 0

import IntUtils BoolUtils ListUtils

library DragonDexLib

type Error =
  | CodeNotContractOwner
  | CodePoolMissing
  | CodeNotWithin
  | CodeCannotBeZero
  | CodeRatesCannotBeFulfilled
  | CodeNotOperator
  | CodeTransactionExpired
  | CodeEmptyAddress
  | CodeMinLP
  | CodeSameAddress

type Denom =
  | Zil
  | Token

type SwapDirection =
  | ZilToToken (* make swap ZIL to token type *)
  | TokenToZil (* make swap token to ZIL type *)
  | TokensToTokens (* make swap token to tokens type *)


let zero_address = 0x0000000000000000000000000000000000000000

let zero128 = Uint128 0
let zero256 = Uint256 0
let zero32 = Uint32 0

let one32 = Uint32 1
let one128 = Uint128 1
let two128 = Uint128 2
let two256 = Uint256 2
let fee_demon = Uint256 10000

let tt = True
let ff = False

let zil_denom = Zil
let zrc_denom = Token

let one_msg = 
  fun (msg : Message) => 
    let nil_msg = Nil {Message} in
      Cons {Message} msg nil_msg

let make_error =
  fun (result : Error) =>
    match result with
    | CodeNotContractOwner =>
      {
        _exception: "Sender is not contract owner";
        code: Int32 -1
      }
    | CodePoolMissing =>
      {
        _exception: "Pool is missing";
        code: Int32 -2
      }
    | CodeNotWithin =>
      {
        _exception: "Amount is not within";
        code: Int32 -3
      }
    | CodeCannotBeZero =>
      {
        _exception: "Value cannot be zero";
        code: Int32 -4
      }
    | CodeRatesCannotBeFulfilled =>
      {
        _exception: "Requested rates cannot be fulfilled";
        code: Int32 -5
      }
    | CodeNotOperator =>
      {
        _exception: "Sender is not operator";
        code: Int32 -6
      }
    | CodeTransactionExpired =>
      {
        _exception: "Deadline blocknumber is expired";
        code: Int32 -7
      }
    | CodeEmptyAddress =>
      {
        _exception: "Incorrect address";
        code: Int32 -8
      }
    | CodeMinLP =>
      {
        _exception: "LP less then min";
        code: Int32 -9
      }
    | CodeSameAddress =>
      {
        _exception: "Input addresses are same";
        code: Int32 -10
      }
    end

let option_value =
  tfun 'A =>
  fun (default: 'A) =>
  fun (opt_val: Option 'A) =>
    match opt_val with
    | Some v => v
    | None => default
    end


let option_uint128 = @option_value Uint128
let addr_exists = @list_exists ByStr20
let list_length_addr = @list_length ByStr20

let grow_u128: Uint128 -> Uint256 =
  fun (v : Uint128) =>
    let some_big = builtin to_uint256 v in
    match some_big with
    | Some big => big
    | None => zero256 (* should never happen *)
    end

let fall_u256: Uint256 -> Uint128 =
  fun (v : Uint256) =>
    let some_u128 = builtin to_uint128 v in
    match some_u128 with
    | Some u => u
    | None => zero128 (* should never happen *)
    end

(* computes the amount of the fraction x / d that is in y *)
let fraction: Uint256 -> Uint256 -> Uint256 -> Uint256 =
fun (d: Uint256) =>
fun (x: Uint256) =>
fun (y: Uint256) =>
  let d_times_y = builtin mul d y in
    builtin div d_times_y x

(* computes the output that should be taken from the output reserve
  when the given input amount is added to the input reserve *)
let output_for: Uint128 -> Uint128 -> Uint128 -> Uint256 =
  fun (input_amount: Uint128) =>
  fun (input_reserve: Uint128) =>
  fun (output_reserve: Uint128) =>
    let exact_amount_u256 = grow_u128 input_amount in
    let input_reserve_u256 = grow_u128 input_reserve in
    let output_reserve_u256 = grow_u128 output_reserve in
    let numerator = builtin mul exact_amount_u256 output_reserve_u256 in
    let denominator = builtin add input_reserve_u256 exact_amount_u256 in
      builtin div numerator denominator


let check_within_limits =
  fun (amount: Uint128) =>
  fun (max_token_amount: Uint128) =>
  fun (new_contribution: Uint128) =>
  fun (min_contribution_amount: Uint128) =>
    let token_lte_max = uint128_le amount max_token_amount in
    let contribution_gte_max = uint128_ge new_contribution min_contribution_amount in
      andb token_lte_max contribution_gte_max


let pool_from_denom =
  fun (denom: Denom) =>
  fun (input_amount: Uint128) =>
  fun (output_amount: Uint128) =>
  fun (x: Uint128) =>
  fun (y: Uint128) =>
    match denom with
    | Zil =>
      let new_x = builtin add x input_amount in
      let new_y = builtin sub y output_amount in
        Pair {Uint128 Uint128} new_x new_y
    | Token =>
      let new_x = builtin sub x output_amount in
      let new_y = builtin add y input_amount in
        Pair {Uint128 Uint128} new_x new_y
    end

let after_fee =
  fun (value: Uint256) =>
  fun (fee: Uint256) =>
    let v_f = builtin mul value fee in
      builtin div v_f fee_demon

let is_empty_pool =
  fun (x: Uint128) =>
  fun (y: Uint128) =>
    let x_empty = builtin lt x one128 in
    let y_empty = builtin lt y one128 in
      orb x_empty y_empty

let check_operators =
  fun (operators: List ByStr20) =>
  fun (sender: ByStr20) =>
    let f =
      fun (a: ByStr20) =>
        builtin eq a sender in
    addr_exists f operators


contract DragonDexContract
(
  init_owner: ByStr20,
  operators: List ByStr20
)


(* Contract owner *)
field owner: ByStr20 = init_owner

(* operators approvals for onwer transfer *)
field transfer_owner_approvals: Map ByStr20 (Map ByStr20 Bool) = Emp ByStr20 (Map ByStr20 Bool)

(* Numbers of approvals for transfer owner. *)
field number_approvals: Uint32 = zero32

(* POOL token -> Pari{zil_reserve, token_reserve} *)
field pools: Map ByStr20 (Pair Uint128 Uint128) = Emp ByStr20 (Pair Uint128 Uint128)

(* token -> full zil_reserve amount *)
field total_contributions: Map ByStr20 Uint128 = Emp ByStr20 Uint128

(* token -> _sender -> started_zil_reserve *)
field balances: Map ByStr20 (Map ByStr20 Uint128) = Emp ByStr20 (Map ByStr20 Uint128)

(* fee for each swap - zil_fee, token_fee *)
field swap_fee: Uint256 = fee_demon

(* Min number zil for LP providers. *)
field min_lp: Uint128 = Uint128 1

(* Pool for increase price with every swap. *)
field rewards_pool: ByStr20 = zero_address

(* A callback for interact with another contract. *)
field callback_addr: ByStr20 = zero_address


procedure ThrowError(err : Error)
  e = make_error err;
  throw e
end

(* EVENTS *)
procedure emitMintPool(token_address: ByStr20, address: ByStr20, amount: Uint128)
  e = {
    _eventname: "Mint";
    pool: token_address;
    address: address;
    amount: amount
  };
  event e
end

(* EVENTS *)

(* Checkers *)
procedure ThrowZero(v: Uint128)
  is_zero = builtin eq v zero128;
  match is_zero with
  | False =>
  | True =>
    err = CodeCannotBeZero;
    ThrowError err
  end
end

procedure ThrowIfSameAddress(address1: ByStr20, address2: ByStr20)
  is_same = builtin eq address1 address2;
  match is_same with
  | False =>
  | True =>
    err = CodeSameAddress;
    ThrowError err
  end
end

procedure CheckMinLP(lp: Uint128)
  min <- min_lp;
  is_min_lp = uint128_ge min lp;
  
  match is_min_lp with
  | True =>
    err = CodeMinLP;
    ThrowError err
  | False =>
  end
end

procedure ThrowExpired(deadline_block: BNum, current_block: BNum)
  is_not_expired = builtin blt current_block deadline_block;
  match is_not_expired with
  | True =>
  | False =>
    err = CodeTransactionExpired;
    ThrowError err
  end
end

procedure ThrowZeroAddress(address: ByStr20)
  is_zil = builtin eq address zero_address;
  match is_zil with
  | False =>
  | True =>
    err = CodeEmptyAddress;
    ThrowError err
  end
end

procedure CheckLimits(
  amount: Uint128,
  limit: Uint128
)
  (* we are given an exact input and are computing the output,
    which should be greater or equal to the limit *)
  is_within_limits = uint128_ge amount limit;

  match is_within_limits with
  | False =>
    err = CodeRatesCannotBeFulfilled;
    ThrowError err
  | True =>
  end
end

procedure OwnerOnly()
  contract_owner <- owner;
  is_owner = builtin eq _sender contract_owner;
  match is_owner with
  | True =>
  | False =>
    err = CodeNotContractOwner;
    ThrowError err
  end
end

procedure OperatorOnly()
  is_operator = check_operators operators _sender;
  match is_operator with
  | True =>
  | False =>
    err = CodeNotOperator;
    ThrowError err
  end
end
(* Checkers *)

(* MSG CALL *)
procedure AddFunds(recipient: ByStr20, amount: Uint128)
  msg = {
    _tag: "AddFunds";
    _recipient: recipient;
    _amount: amount
  };
  msgs = one_msg msg;
  send msgs
end

procedure CallTransferFrom(amount: Uint128, from: ByStr20, to: ByStr20, recipient: ByStr20)
  call_transfer_zlp = {
    _tag: "TransferFrom";
    _recipient: recipient;
    _amount: zero128;
    from: from;
    to: to;
    amount: amount
  };
  msgs = one_msg call_transfer_zlp;
  send msgs
end

procedure CallTransfer(to: ByStr20, amount: Uint128, recipient: ByStr20)
  msg_transfer = {
    _tag: "Transfer";
    _recipient: recipient;
    _amount: zero128;
    to: to;
    amount: amount
  };
  msgs = one_msg msg_transfer;
  send msgs
end

procedure CallBackSwap(
  input_token: ByStr20,
  output_token: ByStr20,
  input_amount: Uint128,
  output_amount: Uint128
)
  recipient <- callback_addr;
  is_empty = builtin eq recipient zero_address;

  e = {
    _eventname: "Swapped";
    initiator: _sender;
    input_token: input_token;
    output_token: output_token;
    input_amount: input_amount;
    output_amount: output_amount
  };
  event e;

  match is_empty with
  | False =>
    call_callback = {
      _tag: "CallBackSwap";
      _recipient: recipient;
      _amount: zero128;
      initiator: _sender;
      input_token: input_token;
      output_token: output_token;
      input_amount: input_amount;
      output_amount: output_amount
    };
    msg = one_msg call_callback;
    send msg
  | True =>
  end
end

procedure CallBackRemoveLiquidity(zil: Uint128, tokens: Uint128)
  recipient <- callback_addr;
  is_empty = builtin eq recipient zero_address;

  match is_empty with
  | False =>
    call_callback = {
      _tag: "CallBackRemoveLiquidity";
      _recipient: recipient;
      _amount: zero128;
      initiator: _sender;
      zil: zil;
      tokens: tokens
    };
    msg = one_msg call_callback;
    send msg
  | True =>
  end
end

procedure CallBackAddLiquidity(zil: Uint128, tokens: Uint128)
  recipient <- callback_addr;
  is_empty = builtin eq recipient zero_address;

  match is_empty with
  | False =>
    call_callback = {
      _tag: "CallBackAddLiquidity";
      _recipient: recipient;
      _amount: zero128;
      initiator: _sender;
      zil: zil;
      tokens: tokens
    };
    msg = one_msg call_callback;
    send msg
  | True =>
  end
end

(* MSG CALL *)

(* iterations *)
procedure ReceiveRewards(zil_rewards: Uint128)
  is_zero = builtin eq zil_rewards zero128;

  match is_zero with
  | True =>
  | False =>
    addr_rewards_pool <- rewards_pool;
    some_pool <- pools[addr_rewards_pool];

    match some_pool with
    | None =>
    | Some pool =>
      match pool with
      | Pair zil tokens =>
        new_zil = builtin add zil zil_rewards;

        e = {
          _eventname: "ZILRewards";
          zil_rewards: zil_rewards
        };
        event e;

        new_pool = Pair {Uint128 Uint128} new_zil tokens;
        pools[addr_rewards_pool] := new_pool
      end
    end
  end
end

procedure MakeSwap(
  token_address: ByStr20,
  input_amount: Uint128,
  output_amount: Uint128,
  denom: Denom,
  zil_reserve: Uint128,
  token_reserve: Uint128
)
  new_pool = pool_from_denom
    denom
    input_amount
    output_amount
    zil_reserve
    token_reserve;
  pools[token_address] := new_pool
end

procedure SwapOptions(
  input_token: ByStr20,
  output_token: ByStr20,
  direction: SwapDirection,
  exact_amount: Uint128,
  limit_amount: Uint128,
  recipient_address: ByStr20
)
  fee <- swap_fee;

  match direction with
  | ZilToToken =>
    some_pool <- pools[output_token];

    match some_pool with
    | Some pool =>
      match pool with
      | Pair zil_reserve token_reserve =>
        exact_amount_u256 = grow_u128 exact_amount;
        exact_amount_after_fee = after_fee exact_amount_u256 fee;
        rewards_amount = builtin sub exact_amount_u256 exact_amount_after_fee;

        rewards_amount = fall_u256 rewards_amount;
        exact_amount_u128 = fall_u256 exact_amount_after_fee;

        calculated_amount_u256 = output_for
          exact_amount_u128
          zil_reserve
          token_reserve;
        calculated_amount_u128 = fall_u256 calculated_amount_u256;

        CheckLimits calculated_amount_u128 limit_amount;
        accept;
        ReceiveRewards rewards_amount;

        MakeSwap
          output_token
          exact_amount_u128
          calculated_amount_u128
          zil_denom
          zil_reserve
          token_reserve;
        CallBackSwap
          input_token
          output_token
          exact_amount_u128
          calculated_amount_u128;
        CallTransfer recipient_address calculated_amount_u128 output_token
      end
    | None =>
      err = CodePoolMissing;
      ThrowError err
    end
  | TokenToZil =>
    some_pool <- pools[input_token];

    match some_pool with
    | Some pool =>
      match pool with
      | Pair zil_reserve token_reserve =>
        calculated_amount_u256 = output_for
          exact_amount
          token_reserve
          zil_reserve;
        calculated_amount_after_fee_u256 = after_fee calculated_amount_u256 fee;
        rewards_amount = builtin sub calculated_amount_u256 calculated_amount_after_fee_u256;
        rewards_amount = fall_u256 rewards_amount;
        calculated_amount_u128 = fall_u256 calculated_amount_after_fee_u256;

        CheckLimits calculated_amount_u128 limit_amount;
        ReceiveRewards rewards_amount;

        MakeSwap
          input_token
          exact_amount
          calculated_amount_u128
          zrc_denom
          zil_reserve
          token_reserve;
      CallBackSwap
        input_token
        output_token
        exact_amount
        calculated_amount_u128;
      CallTransferFrom exact_amount _sender _this_address input_token;
      AddFunds recipient_address calculated_amount_u128
      end
    | None =>
      err = CodePoolMissing;
      ThrowError err
    end
  | TokensToTokens =>
    some_input_pool <- pools[input_token];
    some_output_pool <- pools[output_token];

    match some_input_pool with
    | Some input_pool =>
      match some_output_pool with
      | Some output_pool =>
        match input_pool with
        | Pair input_zil_reserve input_token_reserve =>
          match output_pool with
          | Pair output_zil_reserve output_token_reserve =>
            CallTransferFrom exact_amount _sender _this_address input_token;

            (* Swap input tokens to ZIL. *)
            zil_intermediate_amount_u256 = output_for
              exact_amount
              input_token_reserve
              input_zil_reserve;
            zil_intermediate_amount_after_fee_u256 = after_fee zil_intermediate_amount_u256 fee;
            rewards_amount = builtin sub zil_intermediate_amount_u256 zil_intermediate_amount_after_fee_u256;
            rewards_amount = fall_u256 rewards_amount;
            zil_intermediate_amount_u128 = fall_u256 zil_intermediate_amount_after_fee_u256;

            (* Swap ZIL to output tokens. *)
            calculated_amount_u256 = output_for
              zil_intermediate_amount_u128
              output_zil_reserve
              output_token_reserve;
            calculated_amount_u128 = fall_u256 calculated_amount_u256;

            CheckLimits calculated_amount_u128 limit_amount;
            ReceiveRewards rewards_amount;

            MakeSwap
              input_token
              exact_amount
              zil_intermediate_amount_u128
              zrc_denom
              input_zil_reserve
              input_token_reserve;
            MakeSwap
              output_token
              exact_amount
              calculated_amount_u128
              zil_denom
              output_zil_reserve
              output_token_reserve;
            CallBackSwap
              input_token
              output_token
              exact_amount
              calculated_amount_u128;
            CallTransfer recipient_address calculated_amount_u128 output_token
          end
        end
      | None =>
        err = CodePoolMissing;
        ThrowError err
      end
    | None =>
      err = CodePoolMissing;
      ThrowError err
    end
  end
end
(* iterations *)


(* user interactions *)
transition AddLiquidity(
  token_address : ByStr20,
  min_contribution_amount : Uint128,
  max_token_amount : Uint128,
  deadline_block : BNum
)
  current_block <- & BLOCKNUMBER;

  ThrowExpired deadline_block current_block;
  ThrowZeroAddress token_address;
  ThrowZero max_token_amount;
  ThrowIfSameAddress token_address _sender;
  ThrowIfSameAddress token_address _this_address;

  some_pool <- pools[token_address];

  match some_pool with
  | None =>
    CheckMinLP _amount;
    (* INIT Pool *)
    new_pool = Pair {Uint128 Uint128} _amount max_token_amount;

    CallTransferFrom max_token_amount _sender _this_address token_address;
    accept;

    pools[token_address] := new_pool;
    balances[token_address][_sender] := _amount;
    total_contributions[token_address] := _amount;

    CallBackAddLiquidity _amount max_token_amount;

    pool_event = {
      _eventname: "PoolCreated";
      pool: token_address
    };
    event pool_event;
    emitMintPool token_address _sender _amount
  | Some pool =>
    match pool with
    | Pair zil_reserve token_reserve =>
      some_total_contribution <- total_contributions[token_address];

      total_contribution = option_uint128 zero128 some_total_contribution;

      total_contribution_u256 = grow_u128 total_contribution;
      amount_u256 = grow_u128 _amount;
      zil_reserve_u256 = grow_u128 zil_reserve;
      token_reserve_u256 = grow_u128 token_reserve;

      (* dY = dX * Y / X *)
      (* dX is always the QA transferred *)
      result_u256 = fraction amount_u256 zil_reserve_u256 token_reserve_u256;
      result_u128 = fall_u256 result_u256;

      (* (_amount *  total_contribution) / x *)
      new_contribution_u256 = fraction amount_u256 zil_reserve_u256 total_contribution_u256;
      new_contribution_u128 = fall_u256 new_contribution_u256;

      is_within_limits = check_within_limits
        result_u128
        max_token_amount
        new_contribution_u128
        min_contribution_amount;

      match is_within_limits with
      | True =>
      | False =>
        err = CodeNotWithin;
        ThrowError err
      end;

      CallTransferFrom result_u128 _sender _this_address token_address;
      accept;

      new_x = builtin add zil_reserve _amount;
      new_y = builtin add token_reserve result_u128;
      new_pool = Pair {Uint128 Uint128} new_x new_y;
      pools[token_address] := new_pool;

      CallBackAddLiquidity new_x new_y;

      existing_balance <- balances[token_address][_sender];

      match existing_balance with
      | Some balance =>
        new_balance = builtin add balance new_contribution_u128;
        balances[token_address][_sender] := new_balance
      | None =>
        balances[token_address][_sender] := new_contribution_u128
      end;

      new_total_contribution = builtin add total_contribution new_contribution_u128;
      total_contributions[token_address] := new_total_contribution;

      emitMintPool token_address _sender new_contribution_u128
    end
  end
end

transition RemoveLiquidity(
  token_address: ByStr20,
  contribution_amount: Uint128,
  min_zil_amount: Uint128,
  min_token_amount: Uint128,
  deadline_block: BNum
)
  current_block <- & BLOCKNUMBER;

  ThrowExpired deadline_block current_block;
  ThrowZero contribution_amount;
  ThrowZero min_zil_amount;
  ThrowZero min_token_amount;

  some_pool <- pools[token_address];

  match some_pool with
  | Some pool =>
    match pool with
    | Pair zil_reserve token_reserve =>
      some_total_contribution <- total_contributions[token_address];

      total_contribution_u128 = option_uint128 zero128 some_total_contribution;

      ThrowZero total_contribution_u128;

      zil_reserve_u256 = grow_u128 zil_reserve;
      token_reserve_u256 = grow_u128 token_reserve;

      contribution_amount_u256 = grow_u128 contribution_amount;
      total_contribution_u256 = grow_u128 total_contribution_u128;

      zil_amount_u256 = fraction contribution_amount_u256 total_contribution_u256 zil_reserve_u256;
      token_amount_u256 = fraction contribution_amount_u256 total_contribution_u256 token_reserve_u256;

      zil_amount_u128 = fall_u256 zil_amount_u256;
      token_amount_u128 = fall_u256 token_amount_u256;

      is_within_limits =
        let zil_ok = uint128_ge zil_amount_u128 min_zil_amount in
        let token_ok = uint128_ge token_amount_u128 min_token_amount in
          andb zil_ok token_ok;

      match is_within_limits with
      | True =>
      | False =>
        err = CodeNotWithin;
        ThrowError err
      end;

      some_existing_balance <- balances[token_address][_sender];
      
      existing_balance = option_uint128 zero128 some_existing_balance;

      new_balance = builtin sub existing_balance contribution_amount;
      new_total_contribution = builtin sub total_contribution_u128 contribution_amount;

      new_x = builtin sub zil_reserve zil_amount_u128;
      new_y = builtin sub token_reserve token_amount_u128;
      is_empty_pool = is_empty_pool new_x new_y;

      match is_empty_pool with
      | True =>
        (* clear pool entries when there is no more liquidity *)
        delete pools[token_address];
        delete balances[token_address];
        delete total_contributions[token_address]
      | False =>
        new_pool = Pair {Uint128 Uint128} new_x new_y;

        pools[token_address] := new_pool;
        balances[token_address][_sender] := new_balance;
        total_contributions[token_address] := new_total_contribution
      end;


      CallTransfer _sender token_amount_u128 token_address;
      AddFunds _sender zil_amount_u128;
      CallBackRemoveLiquidity zil_amount_u128 token_amount_u128;

      e = {
        _eventname: "Burnt";
        pool: token_address;
        address: _sender;
        amount: contribution_amount
      };
      event e
    end
  | None =>
    err = CodePoolMissing;
    ThrowError err
  end
end

transition SwapExactZILForTokens(
  token_address : ByStr20,
  min_token_amount : Uint128,
  deadline_block : BNum,
  recipient_address : ByStr20
)
  current_block <- & BLOCKNUMBER;

  ThrowExpired deadline_block current_block;
  ThrowZero _amount;
  ThrowZero min_token_amount;
  ThrowZeroAddress recipient_address;

  direction = ZilToToken;

  SwapOptions
    zero_address
    token_address
    direction
    _amount
    min_token_amount
    recipient_address
end

transition SwapExactTokensForZIL(
  token_address: ByStr20,
  token_amount: Uint128,
  min_zil_amount: Uint128,
  deadline_block: BNum,
  recipient_address: ByStr20
)
  current_block <- & BLOCKNUMBER;

  ThrowExpired deadline_block current_block;
  ThrowZero token_amount;
  ThrowZero min_zil_amount;
  ThrowZeroAddress recipient_address;

  direction = TokenToZil;

  SwapOptions
    token_address
    zero_address
    direction
    token_amount
    min_zil_amount
    recipient_address
end

transition SwapExactTokensForTokens(
  token0_address: ByStr20,
  token1_address: ByStr20,
  token0_amount: Uint128,
  min_token1_amount: Uint128,
  deadline_block: BNum,
  recipient_address: ByStr20
)
  current_block <- & BLOCKNUMBER;

  ThrowExpired deadline_block current_block;
  ThrowZero token0_amount;
  ThrowZero min_token1_amount;
  ThrowZeroAddress recipient_address;
  ThrowIfSameAddress token0_address token1_address;

  direction = TokensToTokens;

  SwapOptions
    token0_address
    token1_address
    direction
    token0_amount
    min_token1_amount
    recipient_address
end
(* user interactions *)


(* admin interactions *)
transition SetRewardsPoolAddress(addr: ByStr20)
  OwnerOnly;
  rewards_pool := addr
end

transition SetFee(new_fee: Uint256)
  OwnerOnly;
  swap_fee := new_fee
end
(* admin interactions *)


(* operator interactions *)
transition TransferOwnership(new_owner: ByStr20)
  OperatorOnly;

  already_voted <- exists transfer_owner_approvals[new_owner][_sender];
  approvals <- number_approvals;

  match already_voted with
  | True =>
    new_approvals = builtin sub approvals one32;
    number_approvals := new_approvals;
    delete transfer_owner_approvals[new_owner][_sender]
  | False =>
    new_approvals = builtin add approvals one32;
    number_of_operators = list_length_addr operators;
    is_enough = builtin eq number_of_operators new_approvals;

    match is_enough with
    | True =>
      delete transfer_owner_approvals[new_owner];
      number_approvals := zero32;
      owner := new_owner
    | False =>
      number_approvals := new_approvals;
      transfer_owner_approvals[new_owner][_sender] := tt
    end
  end
end
(* operator interactions *)


(* callbacks *)
transition RecipientAcceptTransfer(sender: ByStr20, recipient: ByStr20, amount: Uint128)
end

transition RecipientAcceptTransferFrom(initiator: ByStr20, sender: ByStr20, recipient: ByStr20, amount: Uint128)
end

transition TransferFromSuccessCallBack(initiator: ByStr20, sender: ByStr20, recipient: ByStr20, amount: Uint128)
end

transition TransferSuccessCallBack(sender: ByStr20, recipient: ByStr20, amount: Uint128)
end
(* callbacks *)
